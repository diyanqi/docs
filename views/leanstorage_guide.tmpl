{% macro regex(useSingleQuotes = false) -%}
^((?!ticket).)*&dollar;{% if useSingleQuotes == true %}&apos;{% else %}&quot;{% endif %}
{%- endmacro %}
{% macro regexFlutter() -%}
^((?!ticket).)*\&dollar;
{%- endmacro %}

# 数据存储开发指南 · {{platform_name}}

数据存储是云服务提供的核心功能之一，可用于存放和查询应用数据。下面的代码展示了如何创建一个对象并将其存入云端：


{% if platform_name === "JavaScript" %}
```js
// 声明 class
const Todo = AV.Object.extend('Todo');

// 构建对象
const todo = new Todo();

// 为属性赋值
todo.set('title',   '工程师周会');
todo.set('content', '周二两点，全体成员');

// 将对象保存到云端
todo.save().then((todo) => {
  // 成功保存之后，执行其他逻辑
  console.log(`保存成功。objectId：${todo.id}`);
}, (error) => {
  // 异常处理
});
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
db.class('Todo')
  .add({
    title: '工程师周会',
    content: '周二两点，全体成员',
  })
  .then((todo) => {
    // 成功保存之后，执行其他逻辑
    console.log(`保存成功，objectId：${todo.id}`);
  })
  .catch((error) => {
    // 异常处理
  });
```
{% endif %}

{% if platform_name === "Python" %}
```python
# 声明 class
Todo = leancloud.Object.extend('Todo')

# 构建对象
todo = Todo()

# 为属性赋值
todo.set('title',   '工程师周会')
todo.set('content', '周二两点，全体成员')

# 将对象保存到云端
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 构建对象
$todo = new LeanObject("Todo");

// 为属性赋值
$todo->set("title",   "工程师周会");
$todo->set("content", "周二两点，全体成员");

// 将对象保存到云端
$todo->save();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
do {
    // 构建对象
    let todo = LCObject(className: "Todo")

    // 为属性赋值
    try todo.set("title",   value: "工程师周会")
    try todo.set("content", value: "周二两点，全体成员")

    // 将对象保存到云端
    _ = todo.save { result in
        switch result {
        case .success:
            // 成功保存之后，执行其他逻辑
            break
        case .failure(error: let error):
            // 异常处理
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
// 构建对象
LCObject todo = LCObject("Todo");
// 为属性赋值
todo["title"] = "工程师周会";
todo["content"] = "周二两点，全体成员";
// 将对象保存到云端
await todo.save();
```
{% endif %}

{% if platform_name === "Go" %}
```go
import "github.com/leancloud/go-sdk/leancloud"

type Todo struct {
  leancloud.Object
  Title   string `json:"title"`
  Content string `json:"content"`
}

todo := Todo{
  Title: "工程师周会",
  Content: "周二两点，全体成员",
}

if ref, err := client.Class("Todo").Create(&todo); err != nil {
  panic(err)
}
```
{% endif %}

我们为各个平台或者语言开发的 SDK 在底层都是通过 HTTPS 协议调用统一的 REST API，提供完整的接口对数据进行各类操作。

## SDK 安装与初始化


{% if platform_name === "JavaScript" %}
请阅读 [JavaScript 安装指南](sdk_setup-js.html)。
{% endif %}
{% if platform_name === "Python" %}
请阅读 [Python 安装指南](sdk_setup-python.html)。
{% endif %}
{% if platform_name === "PHP" %}
请阅读 [PHP 安装指南](sdk_setup-php.html)。
{% endif %}

{% if platform_name === "Swift" %}
请阅读 [Swift 安装指南](sdk_setup-swift.html)。
{% endif %}
{% if platform_name === "Flutter" %}
请阅读 [Flutter 安装指南](sdk_setup-flutter.html)。
{% endif %}

{% if platform_name === "Go" %}
请阅读 [Go 安装指南](sdk_setup-go.html)
{% endif %}

{% if platform_name === "JavaScript" or platform_name === "JavaScript(next)" %}
## Web 安全

如果在前端使用 JavaScript SDK，当你准备正式发布的时候，请务必在 **控制台 > 设置 > 安全中心** 中配置 **Web 安全域名**，这样可以防止其他人通过外网其他地址盗用你的服务器资源。

不过这样做还不够，因为你的应用是暴露在公网上的，任何人都有可能伪造请求来绕过前面的防范措施。所以云服务还提供了其他方法来保护你的应用安全。参见：

- [数据和安全](data_security.html)
- [ACL 权限管理开发指南](acl-guide.html)
{% endif %}

## 对象

### `{{ baseObjectName }}`

`{{ baseObjectName }}` 是云服务对复杂对象的封装，每个 `{{ baseObjectName }}` 包含若干与 JSON 格式兼容的属性值对（也称键值对，key-value pairs）。这个数据是无模式化的（schema free），意味着你不需要提前标注每个 `{{ baseObjectName }}` 上有哪些 key，你只需要随意设置键值对就可以，云端会保存它。

比如说，一个保存着单个 Todo 的 `{{ baseObjectName }}` 可能包含如下数据：

```json
title:      "给小林发邮件确认会议时间",
isComplete: false,
priority:   2,
tags:       ["工作", "销售"]
```

{% if platform_name === "Go" %}
由于 Go 的类型系统的特性，开发者在使用 `map[string]interface{}` 时需要进行类型断言，所以我们强烈建议开发者在与 SDK 交互的过程中使用自行定义的结构体，并且将 `{{ baseObjectName }}` 作为元数据嵌入到结构体中，SDK 会尽可能将对象上的字段绑定到结构体的对应字段上。

在定义自定义结构体时，除了要嵌入 `{{ baseObjectName }}` 作为元数据外，还需要对希望使用的 **可导出** 字段加上 **JSON Tag**。因为 Go SDK 使用反射来对自定义结构体进行修改，而反射是无法访问结构体的 **非导出字段** 的。

对于上面 Todo 类型，可以定义新的对象类型:

```go
type Todo struct {
  leancloud.Object
  Title      string   `json:"title"`
  IsComplete bool     `json:"isComplete"`
  Priority   int      `json:"priority"`
  Tags       []string `json:"tags"`
}
```
{% endif %}

### 数据类型

`{{ baseObjectName }}` 支持的数据类型包括 `String`、`Number`、`Boolean`、`Object`、`Array`、`Date` 等等。你可以通过嵌套的方式在 `Object` 或 `Array` 里面存储更加结构化的数据。

`{{ baseObjectName }}` 还支持两种特殊的数据类型 `Pointer` 和 `File`，可以分别用来存储指向其他 `{{ baseObjectName }}` 的指针以及二进制数据。{% if platform_name === "Go" %}Go SDK 中 `{{ baseObjectName }}` 类型可以当作 `Pointer` 使用。{% endif %}

`{{ baseObjectName }}` 同时支持 `GeoPoint`，可以用来存储地理位置信息。参见 [GeoPoint](#geopoint)。

以下是一些示例：


{% if platform_name === "JavaScript" %}
```js
// 基本类型
const bool   = true;
const number = 2018;
const string = `${number} 流行音乐榜单`;
const date   = new Date();
const array  = [string, number];
const object = {
  number: number,
  string: string
};

// 构建对象
const TestObject = AV.Object.extend('TestObject');
const testObject = new TestObject();
testObject.set('testNumber',  number);
testObject.set('testString',  string);
testObject.set('testDate',    date);
testObject.set('testArray',   array);
testObject.set('testObject',  object);
testObject.save();
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
db.class('TestObject').add({
  bool: true,
  number: 2021,
  string: 'Hello world!',
  date: new Date(),
  array: [1, 2, 3],
  object: {
    year: 1780,
    first: 'partridge',
    second: 'turtledoves',
    fifth: 'golden rings',
  },
});
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
// 基本类型
int numberValue = 2018;
bool boolValue = true;
String stringValue = 'hello, world';
DateTime now = DateTime.now();
List intList = [1, 2, 3];
Map<String, dynamic> stringMap = {
  'year': 1780,
  'first': 'partridge',
  'second': 'turtledoves',
  'fifth': 'golden rings'
};

// 构建对象
LCObject object = new LCObject('Hello');
object['numberValue'] = numberValue;
object['boolValue'] = boolValue;
object['stringValue'] = stringValue;
object['time'] = now;
object['intList'] = intList;
object['stringMap'] = stringMap;
```
{% endif %}

{% if platform_name === "Python" %}
```python
from datetime import datetime

# 基本类型
bool = True
number = 2018
string = 'Top Hit Songs'
date = datetime.now()
list = [string, number]
dictionary = {
    'number': number,
    'string': string
}

# 构建对象
TestObject = leancloud.Object.extend('TestObject')
test_object = TestObject()
test_object.set('testString', string)
test_object.set('testNumber', number)
test_object.set('testBoolean', bool)
test_object.set('testList', list)
test_object.set('testDict', dictionary)
test_object.set('testDate', date)
test_object.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 基本类型
$bool       = true;
$number     = 2018;
$string     = $number . " 流行音乐榜单";
$date       = new \DateTime();
$mixedArray = array($string, $number);
$dictionary = array("number" => $number, "string" => $string);

// 构建对象
$testObject = new LeanObject("TestObject");
$testObject->set("testBoolean", $bool);
$testObject->set("testNumber", $number);
$testObject->set("testString",  $string);
$testObject->set("testDate", $date);
$testObject->set("testArray", $mixedArray);
$testObject->set("testAssociativeArray", $dictionary);
$testObject->save();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
/* 所有的 LC 数据类型都遵循 LCValue 协议，即它们也都是 LCValue 类型 */

// 构建 LC 基础类型
let number       : LCNumber       = LCNumber(42)
let bool         : LCBool         = LCBool(true)
let string       : LCString       = LCString("foo")
let dictionary   : LCDictionary   = LCDictionary(["name": string, "count": number])
let array        : LCArray        = LCArray([number, bool, string])
let emptyData    : LCData         = LCData(Data())
let currentDate  : LCDate         = LCDate(Date())
let null         : LCNull         = LCNull()
let geoPoint     : LCGeoPoint     = LCGeoPoint(latitude: 45, longitude: -45)
let acl          : LCACL          = LCACL()

// LC 基础类型转换为 Swift 标准数据类型
let swiftInt:        Int?              = number.intValue
let swiftDouble:     Double            = number.value
let swiftBool:       Bool              = bool.value
let swiftString:     String            = string.value
let swiftDictionary: [String: LCValue] = dictionary.value
let swiftArray:      [LCValue]         = array.value

// 构建 LC 对象类型
let object       : LCObject       = LCObject()
let relation     : LCRelation     = object.relationForKey("elements") // LCRelation 没有继承 LCObject
let user         : LCUser         = LCUser()
let file         : LCFile         = LCFile()
let installation : LCInstallation = LCInstallation()

/* LC 对象类型的 Setter 方法 */

// 1. 调用 set(_:value:) 函数，此方式会检查 value 是否有效
do {
    try object.set("number", value: 42)
    try object.set("number", value: LCNumber(42))
} catch {
    print(error)
}

// 2. subscript 方式，此方式不会检查 value 是否有效
object["number"] = 42.lcValue
object["number"] = LCNumber(42)

/* LC 对象类型的 Getter 方法 */

// 1. 调用 get(_:) 函数
let getNumber1: LCNumber? = object.get("number") as? LCNumber

// 2. subscript 方式
let getNumber2: LCNumber? = object["number"] as? LCNumber
```
{% endif %}
{% if platform_name === "Go" %}
```go
// 基本类型
boolean := true
number := 2021
str := "LeanCloud"
date := time.Now()
slice := []byte("LeanCloud")
point := leancloud.GeoPoint{
  Latitude: 39.9,
  Longitude: 116.4,
}

// 定义结构体
type Meeting struct {
  leancloud.Object
  Title      string     `json:"title"`
  Number     int        `json:"number"`
  Progress   float64    `json:"progress"`
  Date       time.Time  `json:"date"`
  Attachment []byte     `json:"attachment"`
}

// 构建对象
meeting := Meeting{
  Title: "Meeting",
  Number: 1,
  Progress: 10.0,
  Date: time.Now(),
  Attachment: []byte("Attachment content"),
}
```
{% endif %}

我们不推荐{% if platform_name === "JavaScript" %}{% endif %}{% if platform_name === "Python" %}通过 `byte[]` {% endif %}{% if platform_name === "PHP" %}通过 `Bytes` {% endif %}{% if platform_name === "Swift" %}通过 `LCData` {% endif %}{% if platform_name === "Flutter" %}通过 `Uint8List` {% endif %}在 `{{ baseObjectName }}` 里面存储图片、文档等大型二进制数据。每个 `{{ baseObjectName }}` 的大小不应超过 **128 KB**。如需存储大型文件，可创建 `{{ fileObjectName }}` 实例并将将其关联到 `{{ baseObjectName }}` 的某个属性上。参见 [文件](#文件)。

注意：时间类型在云端将会以 UTC 时间格式存储，但是客户端在读取之后会转化成本地时间。

**云服务控制台 > 数据存储 > 结构化数据** 中展示的日期数据也会依据操作系统的时区进行转换。一个例外是当你通过 REST API 获得数据时，这些数据将以 UTC 呈现。你可以手动对它们进行转换。

若想了解云服务是如何保护应用数据的，请阅读《数据和安全》。

{% if platform_name === "Swift" %}

#### 基础类型数据的构建与转换

`LCObject` 无法直接支持 Swift 语言的基础数据类型，例如 `Int`、`Double`、`String`、`Bool`、`Array`、`Dictionary` 等等。相对的，SDK 提供了 `LCNumber`、`LCString`、`LCBool`、`LCArray`、`LCDictionary` 等类型，来支持 `LCObject` 与 Swift 语言的交互。

##### LCNumber

`LCObject` 对象中的数字均为 `LCNumber` 类型。`LCNumber` 的构建方法如下：

```swift
let intNum: LCNumber = LCNumber(1)
let doubleNum: LCNumber = LCNumber(0.1)
```

Swift 语言的数字类型也可以与 `LCNumber` 进行相互转换：

```swift
let intNum: LCNumber = 1.lcNumber
let int: Int? = intNum.intValue
let doubleNum: LCNumber = 0.1.lcNumber
let double: Double? = doubleNum.doubleValue
```

另外，`LCObject` 也支持隐式的将 Swift 语言的数字类型自动转换为 `LCNumber`：

```swift
let object = LCObject()
// set 方法会自动将 1 以及 0.1 转换为 LCNumber
try object.set("int", value: 1)
try object.set("double", value: 0.1)
```

##### LCBool

`LCObject` 对象中的布尔值为 `LCBool` 类型。`LCBool` 的构建方法如下：

```swift
let lcBool: LCBool = LCBool(true)
```

Swift 语言的布尔值也可以与 `LCBool` 进行相互转换：

```swift
let lcBool: LCBool = LCBool(true)
let bool: Bool? = lcBool.boolValue
```

另外，`LCObject` 也支持隐式的将 Swift 语言的布尔值自动转换为 `LCBool`：

```swift
let object = LCObject()
// set 方法会自动将 true 转换为 LCBool
try object.set("bool", value: true)
```

##### LCString

`LCObject` 对象中的字符串为 `LCString` 类型。`LCString` 的构建方法如下：

```swift
let lcString: LCString = LCString("string")
```

Swift 语言的字符串也可以与 `LCString` 进行相互转换：

```swift
let lcString: LCString = LCString("string")
let string: String? = lcString.stringValue
```

另外，`LCObject` 也支持隐式的将 Swift 语言的字符串自动转换为 `LCString`：

```swift
let object = LCObject()
// set 方法会自动将 "stringValue" 转换为 LCString
try object.set("string", value: "stringValue")
```

##### LCArray

`LCObject` 对象中的数组为 `LCArray` 类型。`LCArray` 的构建方法如下：

```swift
let lcArray: LCArray = LCArray([1, "string"])
```

Swift 语言的数组也可以与 `LCArray` 进行相互转换：

```swift
let lcArray: LCArray = LCArray([1, "string"])
let array: Array? = lcArray.arrayValue
```

**注意**，`LCObject` 不支持隐式的将 Swift 语言的数组自动转换为 `LCArray`，所以需要显式的设置：

```swift
let object = LCObject()
// value 需显式的指定为 LCArray 类型
try object.set("array", value: LCArray([1, "string"]))
```

##### LCDictionary

`LCObject` 对象中的字典为 `LCDictionary` 类型。`LCDictionary` 的构建方法如下：

```swift
let lcDictionary: LCDictionary = LCDictionary([
    "key1" : 1,
    "key2" : true,
    "key3" : "string",
])
```

Swift 语言的字典也可以与 `LCDictionary` 进行相互转换：

```swift
let lcDictionary: LCDictionary = LCDictionary([
    "key1" : 1,
    "key2" : true,
    "key3" : "string",
])
let dictionary: Dictionary? = lcDictionary.dictionaryValue
```

**注意**，`LCObject` 不支持隐式的将 Swift 语言的字典自动转换为 `LCDictionary`，所以需要显式的设置：

```swift
let object = LCObject()
// value 需显式的指定为 LCDictionary 类型
try object.set("dictionary", value: LCDictionary([
    "key1" : 1,
    "key2" : true,
    "key3" : "string",
]))
```

另外，`LCDictionary` 类型自身也支持更新操作：

```swift
let lcDictionary: LCDictionary = LCDictionary([
    "key1" : 1,
    "key2" : true,
    "key3" : "string",
])
// value 需为 LCValue 类型
lcDictionary.set("key1", LCNumber(2))
lcDictionary.set("key2", false.lcBool)
```

##### LCData

`LCObject` 对象中的二进制数据为 `LCData` 类型。`LCData` 的构建方法如下：

```swift
let emptyData = Data()
let lcData: LCData = LCData(emptyData)
```

Swift 语言的二进制数据也可以与 `LCData` 进行相互转换：

```swift
let emptyData = Data()
let lcData: LCData = LCData(emptyData)
let data: Data? = lcData.dataValue
```

另外，`LCObject` 也支持隐式的将 Swift 语言的二进制数据自动转换为 `LCData`：

```swift
let emptyData = Data()
let object = LCObject()
// set 方法会自动将 emptyData 转换为 LCData
try object.set("data", value: emptyData)
```

##### LCDate

`LCObject` 对象中的时间数据为 `LCDate` 类型。`LCDate` 的构建方法如下：

```swift
let currentDate = Date()
let lcDate = LCDate(currentDate)
```

Swift 语言的时间数据也可以与 `LCDate` 进行相互转换：

```swift
let currentDate = Date()
let lcDate = LCDate(currentDate)
let date: Date? = lcDate.dateValue
```

另外，`LCObject` 也支持隐式的将 Swift 语言的时间数据自动转换为 `LCDate`：

```swift
let currentDate = Date()
let object = LCObject()
// set 方法会自动将 currentDate 转换为 LCDate
try object.set("date", value: currentDate)
```

{% endif %}

{% if platform_name not in ["Go", "JavaScript(next)"] %}

### 构建对象

下面的代码构建了一个 class 为 `Todo` 的 `{{ baseObjectName }}`：


{% if platform_name === "JavaScript" %}
```js
// 为 AV.Object 创建子类
const Todo = AV.Object.extend('Todo');

// 为该类创建一个新实例
const todo = new Todo();

// 你还可以直接使用 AV.Object 的构造器
const todo = new AV.Object('Todo');
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 为 leancloud.Object 创建子类
Todo = leancloud.Object.extend('Todo')

# 为该类创建一个新实例
todo = Todo()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = new LeanObject("Todo");

// 等同于
$todo = LeanObject::create("Todo");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo")
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCObject object = LCObject('Todo');
```
{% endif %}

在构建对象时，为了使云端知道对象属于哪个 class，需要将 class 的名字作为参数传入。你可以将云服务里面的 class 比作关系型数据库里面的表。一个 class 的名字必须以字母开头，且只能包含数字、字母和下划线。

{% if platform_name === "JavaScript" %}

注意，如果你的应用时不时出现 `Maximum call stack size exceeded` 异常，可能是因为在循环或回调中调用了 `AV.Object.extend`。有两种方法可以避免这种异常：一种是在循环或回调外声明 class，确保不会对一个 class 执行多次 `AV.Object.extend`；另一种是将 SDK 更换到 1.4 或更高版本。

如果你使用的是 ES6，还可以通过 `extends` 关键字来创建 `AV.Object` 的子类，然而 SDK 无法自动识别你创建的子类。你需要通过这种方式手动注册一下：

```js
class Todo extends AV.Object {
  // 自定义属性和方法
}

// 注册子类
AV.Object.register(Todo);
```

这样你就能在 `AV.Object` 的子类中添加额外的方法和属性了。
{% endif %}
{% endif %}


### 保存对象

下面的代码将一个 class 为 `Todo` 的对象存入云端：


{% if platform_name === "JavaScript" %}
```js
// 声明 class
const Todo = AV.Object.extend('Todo');

// 构建对象
const todo = new Todo();

// 为属性赋值
todo.set('title', '马拉松报名');
todo.set('priority', 2);

// 将对象保存到云端
todo.save().then((todo) => {
  // 成功保存之后，执行其他逻辑
  console.log(`保存成功。objectId：${todo.id}`);
}, (error) => {
  // 异常处理
});
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
db.class('Todo')
  .add({
    title: '马拉松报名',
    priority: 2,
  })
  .then((todo) => {
    // 成功保存之后，执行其他逻辑
    console.log(`保存成功，objectId：${todo.id}`);
  })
  .catch((error) => {
    // 异常处理
  });
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 声明 class
Todo = leancloud.Object.extend('Todo')

# 构建对象
todo = Todo()

# 为属性赋值
todo.set('title', '马拉松报名')
todo.set('priority', 2)

# 将对象保存到云端
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 构建对象
$todo = new LeanObject("Todo");

// 为属性赋值
$todo->set("title", "马拉松报名");
$todo->set("priority", 2);

// 将对象保存到云端
$todo->save();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
do {
    // 构建对象
    let todo = LCObject(className: "Todo")

    // 为属性赋值
    try todo.set("title", value: "马拉松报名")
    try todo.set("priority", value: 2)

    // 将对象保存到云端
    _ = todo.save { result in
        switch result {
        case .success:
            // 成功保存之后，执行其他逻辑
            break
        case .failure(error: let error):
            // 异常处理
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```
// 构建对象
LCObject todo = LCObject("Todo");
// 为属性赋值
todo['title'] = '马拉松报名';
todo['priority'] = 2;
// 将对象保存到云端
await todo.save();
```
{% endif %}

{% if platform_name === "Go" %}
Go SDK 支持 **自定义类型** 或 **hashmap** 创建对象:

```go
// 使用自定义类型
type Todo struct {
  leancloud.Object
  Title    string `json:"title"`
  Priority string `json:"priority"`
}

todo := Todo {
  Title: "马拉松报名",
  Priority: 2,
}

if ref, err := client.Class("Todo").Create(&todo); err != nil {
    panic(err)
}

// 使用 map
if ref, err := client.Class("Todo").Create(map[string]interface{}{
    "title": "马拉松报名",
    "priority": 2,
}); err != nil {
    panic(err)
}
```
{% endif %}

为了确认对象已经保存成功，我们可以到 **云服务控制台 > 数据存储 > 结构化数据 > `Todo`** 里面看一下，应该会有一行新的数据产生。点一下这个数据的 `objectId`，应该能看到类似这样的内容：

```json
{
  "title":     "马拉松报名",
  "priority":  2,
  "ACL": {
    "*": {
      "read":  true,
      "write": true
    }
  },
  "objectId":  "582570f38ac247004f39c24b",
  "createdAt": "2017-11-11T07:19:15.549Z",
  "updatedAt": "2017-11-11T07:19:15.549Z"
}
```

注意，无需在 **云服务控制台 > 数据存储 > 结构化数据** 里面创建新的 `Todo` class 即可运行前面的代码。如果 class 不存在，它将自动创建。

以下是一些对象的内置属性，会在对象保存时自动创建，无需手动指定：

内置属性 | 类型 | 描述
--- | --- | ---
`objectId` | `{% if platform_name === "JavaScript" or platform_name === "JavaScript(next)" %}String{% endif %}{% if platform_name === "Python" %}str{% endif %}{% if platform_name === "PHP" %}String{% endif %}{% if platform_name === "Swift" %}LCString{% endif %}{% if platform_name === "Flutter" %}String{% endif %}{% if platform_name === "Go"%}string{% endif %}` | 该对象唯一的 ID 标识。
`ACL` | `{% if platform_name === "JavaScript" %}AV.ACL{% endif %}{% if platform_name === "JavaScript(next)" %}ACL{% endif %}{% if platform_name === "Python" %}leancloud.ACL{% endif %}{% if platform_name === "PHP" %}ACL{% endif %}{% if platform_name === "Swift" %}LCACL{% endif %}{% if platform_name === "Flutter" %}LCACL{% endif %}{% if platform_name === "Go"%}ACL{% endif %}` | 该对象的权限控制，实际上是一个 JSON 对象，控制台做了展现优化。
`createdAt` | `{% if platform_name === "JavaScript" or platform_name === "JavaScript(next)" %}Date{% endif %}{% if platform_name === "Python" %}datetime.datetime{% endif %}{% if platform_name === "PHP" %}DateTime{% endif %}{% if platform_name === "Swift" %}LCDate{% endif %}{% if platform_name === "Flutter" %}DateTime{% endif %}{% if platform_name === "Go"%}time.Time{% endif %}` | 该对象被创建的时间。
`updatedAt` | `{% if platform_name === "JavaScript" or platform_name === "JavaScript(next)" %}Date{% endif %}{% if platform_name === "Python" %}datetime.datetime{% endif %}{% if platform_name === "PHP" %}DateTime{% endif %}{% if platform_name === "Swift" %}LCDate{% endif %}{% if platform_name === "Flutter" %}DateTime{% endif %}{% if platform_name === "Go"%}time.Time{% endif %}` | 该对象最后一次被修改的时间。


这些属性的值会在对象被存入云端时自动填入，代码中尚未保存的 `{{ baseObjectName }}` 不存在这些属性。

属性名（**keys**）只能包含字母、数字和下划线。自定义属性不得以双下划线（`__`）开头或与任何系统保留字段和内置属性（`ACL`、`className`、`createdAt`、`objectId` 和 `updatedAt`）重名，无论大小写。

属性值（**values**）可以是字符串、数字、布尔值、数组或字典（任何能以 JSON 编码的数据）。参见 [数据类型](#数据类型)。

我们推荐使用驼峰式命名法（CamelCase）为类和属性来取名。类，采用大驼峰法，如 `CustomData`。属性，采用小驼峰法，如 `imageUrl`。

### 获取对象

对于已经保存到云端的 `{{ baseObjectName }}`，可以通过它的 `objectId` 将其取回：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
query.get('582570f38ac247004f39c24b').then((todo) => {
  // todo 就是 objectId 为 582570f38ac247004f39c24b 的 Todo 实例
  const title     = todo.get('title');
  const priority  = todo.get('priority');

  // 获取内置属性
  const objectId  = todo.id;
  const updatedAt = todo.updatedAt;
  const createdAt = todo.createdAt;
});
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
db.class('Todo')
  .object('582570f38ac247004f39c24b')
  .get()
  .then((todo) => {
    // 获取属性
    const title = todo.data.title;
    const priority = todo.data.priority;
    const objectId = todo.data.objectId;
    const updatedAt = todo.data.updatedAt;
    const createdAt = todo.data.createdAt;
  });
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
todo = query.get('582570f38ac247004f39c24b')

# todo 就是 objectId 为 582570f38ac247004f39c24b 的 Todo 实例
title      = todo.get('title')
priority   = todo.get('priority')

# 获取内置属性
object_id  = todo.id
update_at  = todo.updated_at
created_at = todo.created_at
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$todo = $query->get("582570f38ac247004f39c24b");

// 获取内置属性
$objectId = $todo->getObjectId();
$updatedAt = $todo->getUpdatedAt();
$createdAt = $todo->getCreatedAt();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
let _ = query.get("582570f38ac247004f39c24b") { (result) in
    switch result {
    case .success(object: let todo):
        // todo 就是 objectId 为 582570f38ac247004f39c24b 的 Todo 实例
        let title     = todo.get("title")
        let priority  = todo.get("priority")

        // 获取内置属性
        let objectId  = todo.objectId
        let updatedAt = todo.updatedAt
        let createdAt = todo.createdAt
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Todo');
LCObject todo = await query.get('582570f38ac247004f39c24b');
// todo 就是 objectId 为 582570f38ac247004f39c24b 的 Todo 实例
String title = todo['title'];
int priority = todo['priority'];

// 获取内置属性
String objectId = todo.objectId;
DateTime updatedAt = todo.updatedAt;
DateTime createdAt = todo.createdAt;
```
{% endif %}

{% if platform_name === "Go" %}
在使用 Go SDK 获取已经保存到云端的对象时，我们推荐使用自定义类型对象；如果不想使用自定义类型的对象，也可以直接使用 `{{ baseObjectName }}`。

```go
// 使用自定义类型对象
todo := new(Todo)
if err := client.Class("Todo").ID("582570f38ac247004f39c24b").Get(todo); err != nil {
  panic(err)
}

// 使用 Object
object := new(leancloud.Object)
if err := client.Class("Todo").ID("582570f38ac247004f39c24b").Get(object); err != nil {
  panic(err)
}
```
使用自定义类型对象时，SDK 会将对象的字段尽力绑定到自定义类型对象的导出字段上；

使用 `{{ baseObjectName }}` 获取对象时，可以使用 ` {{ baseObjectName}}.Raw()` 来获取对象的 `map[string]interface{}` 原始数据；或者使用 `{{ baseObjectName }}` 提供的一系列[类型转换方法](https://pkg.go.dev/github.com/leancloud/go-sdk/leancloud#Object)来获取对象上某个属性的值。
{% endif %}

{% if platform_name === "JavaScript(next)" %}
对象拿到之后，可以通过 `data` 来获取各个属性的值。注意 `objectId`、`updatedAt` 和 `createdAt` 这三个内置属性不能修改，只能由云端自动进行填充。
{% endif %}
{% if platform_name not in ["Go", "JavaScript(next)"] %}
对象拿到之后，可以通过 `get` 方法来获取各个属性的值。注意 `objectId`、`updatedAt`和`createdAt` 这三个内置属性不能通过 `get` 获取或通过 `set` 修改，只能由云端自动进行填充。尚未保存的 `{{ baseObjectName }}` 不存在这些属性。
{% endif %}
{% if platform_name !== "Go" %}
如果你试图获取一个不存在的属性，SDK 不会报错，而是会返回 `{% if platform_name in ["Objective-C", "Swift"] %}nil{% endif %}{% if platform_name in ["JavaScript", "JavaScript(next)"] %}undefined{% endif %}{% if platform_name === "Python" %}None{% endif %}{% if platform_name in ["Android / Java", "PHP"] %}null{% endif %}`。
{% endif %}


{% if platform_name === "JavaScript" %}
如果需要一次性获取返回对象的所有属性（比如进行数据绑定）而非显式地调用 `get`，可以利用 `AV.Object` 实例的 `toJSON` 方法：

```js
const query = new AV.Query('Todo');
query.get('582570f38ac247004f39c24b').then((todo) => {
  console.log(todo.toJSON());
  // {
  //   createdAt: "2017-03-08T11:25:07.804Z",
  //   objectId: "582570f38ac247004f39c24b",
  //   priority: 2,
  //   title: "工程师周会",
  //   updatedAt: "2017-03-08T11:25:07.804Z"
  // }
});
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
如果需要一次性获取返回对象的所有属性（比如进行数据绑定），可以利用 `{{ baseObjectName }}` 实例的 `toJSON` 方法：

```js
db.class('Todo')
  .object('582570f38ac247004f39c24b')
  .get()
  .then((todo) => {
    console.log(todo.toJSON());
    // {
    //   createdAt: "2017-03-08T11:25:07.804Z",
    //   objectId: "582570f38ac247004f39c24b",
    //   priority: 2,
    //   title: "工程师周会",
    //   updatedAt: "2017-03-08T11:25:07.804Z"
    // }
  });
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Android / Java" or platform_name === "Swift" %}
#### 同步对象

当云端数据发生更改时，你可以调用 `{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Python" %}fetch{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}` 方法来刷新对象，使之与云端数据同步：
{% endif %}


{% if platform_name === "JavaScript" %}
```js
const todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.fetch().then((todo) => {
  // todo 已刷新
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo.create_without_data('582570f38ac247004f39c24b')
todo.fetch()
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
_ = todo.fetch { result in
    switch result {
    case .success:
        // todo 已刷新
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCObject todo = LCObject.createWithoutData('Todo', '582570f38ac247004f39c24b');
await todo.fetch();
//todo 已刷新
```
{% endif %}


{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Android / Java" or platform_name === "Swift" %}
刷新操作会强行使用云端的属性值覆盖本地的属性。因此如果本地有属性修改，**`{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}` 操作会丢弃这些修改**。为避免这种情况，你可以在刷新时指定 **需要刷新的属性**，这样只有指定的属性会被刷新（包括内置属性 `objectId`、`createdAt` 和 `updatedAt`），其他属性不受影响。
{% endif %}


{% if platform_name === "JavaScript" %}
```js
const todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.fetch({
  keys: 'priority, location'
}).then((todo) => {
  // 只有 priority 和 location 会被获取和刷新
});
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
todo.fetch(keys: ["priority", "location"]) { (result) in
    switch result {
    case .success:
        // 只有 priority 和 location 会被获取和刷新
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCObject todo = LCObject.createWithoutData('Todo', '582570f38ac247004f39c24b');
await todo.fetch(includes: ['priority','location']);
// 只有 priority 和 location 会被获取和刷新
```
{% endif %}


### 更新对象

{% if platform_name === "Go" %}
在使用 Go SDK 时，更新对象和创建对象相同，可以使用自定义类型对象或者 `map`。

在使用自定义类型的对象时，只需要填充想要更新的字段即可，其它字段默认会被初始化为零值，在执行更新操作时 SDK 会忽略对象中的零值字段。注意：**如果想要更新某个字段为对应类型的零值，应该将该字段声明为指针类型。**

```go
// 使用自定义类型对象更新
diff := Todo{
  Title: "Another Meeting",
}

if err := client.Class("Todo").ID("582570f38ac247004f39c24b").Update(diff); err != nil {
  panic(err)
}

// 使用 map[string]interface{} 更新

if err := client.Class("Todo").ID("582570f38ac247004f39c24b").Update(map[string]interface{}{
  "title": "Another Meeting",
}); err != nil {
  panic(err)
}
```

如果已经有之前保存的对象，则可以使用 client.Object(todo).Update 代替 client.Class("Todo").ID(id).Update 来更新对象。

#### 关于 Go 中的零值

由于 Go 的特性，所有的变量在被声明后都会被初始化为对应类型的 **零值**，例如 `int` 的零值为 `0`，`string` 的零值为 `""`等等。你可以通过嵌套的方式在

那么在使用 `Update` 时传入自定义结构体就会带来一个问题：字段的零值到底是用户设置的还是被默认初始化的？

想要解决这个问题只需要将字段的类型变为相应的指针类型即可:
```go
// 定义结构体
type Todo struct {
  leancloud.Object
  Title string `json:"title"`
  Content string `json:"content"`
  Order *int // 可以指定一个编号，如果不指定则为空不应为 0  
}
```
由于字段变为了指针类型，如果不对字段赋值，那么该字段为指针的零值 `nil`，而不是对应非指针类型的零值，这样就不会产生二义性问题。

另一种解决方案则是则是不使用自定义结构体，转而使用 `map[string]interface{}`。对于 `map[string]interface{}` 来说，如果 `key` 不存在，则 `value` 也不存在，不会产生自定义结构体字段的零值问题。

#### 有条件更新对象

通过传入查询参数 `Query`，可以按照指定条件去更新对象——当条件满足时，执行更新，条件不满足时，不执行更新并返回 `305` 错误。

例如，用户的账户表 `Account` 有一个余额字段 `balance`。为避免余额出现负值，只有当金额小于或等于余额的时候才能接受请求：
```go
query := client.Class("Account").NewQuery().GreaterThanOrEqualTo("balance", 100)

if err := client.Class("Account").ID("5745557f71cfe40068c6abe0").UpdateWithQuery(map[string]interface{}{
    "balance": leancloud.OpIncrement(-100),
}, query); err != nil {
    panic(err)
}
```
{% endif %}


{% if platform_name === "JavaScript" %}
要更新一个对象，只需指定需要更新的属性名和属性值，然后调用 `save` 方法。例如：
```js
const todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.set('content', '这周周会改到周三下午三点。');
todo.save();
```
云服务会自动识别需要更新的属性并将对应的数据发往云端，未更新的属性会保持原样。
{% endif %}
{% if platform_name === "JavaScript(next)" %}
要更新一个对象，只需调用 `update` 方法并提供需要更新的属性名和属性值。例如：
```js
db.class('Todo').object('582570f38ac247004f39c24b').update({
  content: '这周周会改到周三下午三点。',
});
```
未更新的属性会保持原样。
{% endif %}
{% if platform_name === "Python" %}
要更新一个对象，只需指定需要更新的属性名和属性值，然后调用 `save` 方法。例如：
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo.create_without_data('582570f38ac247004f39c24b')
todo.set('content', '这周周会改到周三下午三点。')
todo.save()
```
云服务会自动识别需要更新的属性并将对应的数据发往云端，未更新的属性会保持原样。
{% endif %}
{% if platform_name === "PHP" %}
要更新一个对象，只需指定需要更新的属性名和属性值，然后调用 `save` 方法。例如：
```php
$todo = LeanObject::create("Todo", "582570f38ac247004f39c24b");
$todo->set("content", '这周周会改到周三下午三点。');
$todo->save();
```
云服务会自动识别需要更新的属性并将对应的数据发往云端，未更新的属性会保持原样。
{% endif %}

{% if platform_name === "Swift" %}
要更新一个对象，只需指定需要更新的属性名和属性值，然后调用 `save` 方法。例如：
```swift
do {
    let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
    try todo.set("content", value: "这周周会改到周三下午三点。")
    todo.save { (result) in
        switch result {
        case .success:
            break
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```
云服务会自动识别需要更新的属性并将对应的数据发往云端，未更新的属性会保持原样。
{% endif %}
{% if platform_name === "Flutter" %}
要更新一个对象，只需指定需要更新的属性名和属性值，然后调用 `save` 方法。例如：
```dart
LCObject todo = LCObject.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo['content'] = '这周周会改到周三下午三点。';
await todo.save();
```
云服务会自动识别需要更新的属性并将对应的数据发往云端，未更新的属性会保持原样。
{% endif %}

{% if platform_name === "JavaScript" %}
如果想要查看哪些属性有尚未保存的修改，可以调用 `dirtyKeys` 方法：

```js
todo.dirtyKeys() // ['content']
```

如果希望撤销尚未保存的修改，可以调用 `revert` 方法。
直接调用 `revert()` 将撤销所有尚未保存的修改，
还可以额外传入 `keys` 数组作为参数，指定需要撤销的属性，例如：

```js
todo.revert(['content'])
```
{% endif %}

{% if platform_name in ["Objective-C", "JavaScript", "JavaScript(next)", "Python", "Android / Java", "Swift"] %}
#### 有条件更新对象

通过传入 `query` 选项，可以按照指定条件去更新对象——当条件满足时，执行更新；条件不满足时，不执行更新并返回 `305` 错误。

例如，用户的账户表 `Account` 有一个余额字段 `balance`，同时有多个请求要修改该字段值。为避免余额出现负值，只有当金额小于或等于余额的时候才能接受请求：
{% endif %}


{% if platform_name === "JavaScript" %}
```js
const account = AV.Object.createWithoutData('Account', '5745557f71cfe40068c6abe0');
// 对 balance 原子减少 100
const amount = -100;
account.increment('balance', amount);
account.save(null, {
  // 设置条件
  query: new AV.Query('Account').greaterThanOrEqualTo('balance', -amount),
  // 操作结束后，返回最新数据。
  // 如果是新对象，则所有属性都会被返回，
  // 否则只有更新的属性会被返回。
  fetchWhenSave: true
}).then((account) => {
  console.log(`当前余额为：${account.get('balance')}`);
}, (error) => {
  if (error.code === 305) {
    console.error('余额不足，操作失败！');
  }
});
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
db.class('Account')
  .object('5745557f71cfe40068c6abe0')
  .update(
    {
      // 对 balance 原子减少 100
      balance: db.op.decrement(100),
    },
    {
      // 设置条件
      query: db.class('Account').where('balance', '>=', 100),
      // 返回被更新的属性
      fetchUpdatedData: true,
    }
  )
  .then((account) => {
    console.log(`当前余额为：${account.data.balance}`);
  })
  .catch((error) => {
    if (error.code === 305) {
      console.error('余额不足，操作失败！');
    }
  });
```
`query` 选项在有多个客户端需要更新同一属性的时候非常有用。
{% endif %}
{% if platform_name === "Python" %}
```python
Account = leancloud.Object.extend('Account')
account = Account.create_without_data('5745557f71cfe40068c6abe0')
# 对 balance 原子减少 100
amount = -100
account.increment('balance', amount)
# 设置条件
where = Account.query.greater_than_or_equal_to('balance', -amount)
# 操作结束后，返回最新数据。
# 如果是新对象，则所有属性都会被返回，
# 否则只有更新的属性会被返回。
account.fetch_when_save = True
try:
    account.save(where=where)
    print('当前余额为：', account.get('balance'))
except leancloud.LeanCloudError as e:
    if e.code == 305:
        print('余额不足，操作失败！')
    else:
        raise
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
do {
    let account = LCObject(className: "Account", objectId: "5745557f71cfe40068c6abe0")
    // 对 balance 原子减少 100
    let amount = -100
    try account.increase("balance", by: amount)
    // 设置条件
    let query = LCQuery(className: "Account")
    query.whereKey("balance", .greaterThanOrEqualTo(-amount))
    let options: [LCObject.SaveOption] = [
        .query(query),
        // 操作结束后，返回最新数据。
        // 如果是新对象，则所有属性都会被返回，
        // 否则只有更新的属性会被返回。
        .fetchWhenSave
    ]
    account.save(options: options) { (result) in
        switch result {
        case .success:
            if let balance = account["balance"] {
                print("当前余额为：\(balance)")
            }
        case .failure(error: let error):
            if error.code == 305 {
                print("余额不足，操作失败！")
            }
        }
    }
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
try {
  LCObject account = LCObject.createWithoutData('Account', '5745557f71cfe40068c6abe0');
  // 对 balance 原子减少 100
  int amount = -100;
  account.increment('balance', amount);
// 设置条件
  LCQuery<LCObject> query = LCQuery('Account');
  query.whereGreaterThanOrEqualTo('balance', -amount);
  // 操作结束后，返回最新数据。
  // 如果是新对象，则所有属性都会被返回，
  // 否则只有更新的属性会被返回。
  await account.save(fetchWhenSave: true, query: query);
  print('当前余额为：${account['balance']}');
} on LCException catch (e) {
  if (e.code == 305) {
    print("余额不足，操作失败！");
  }
}
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Android / Java" or platform_name === "Swift" %}
**`query` 选项只对已存在的对象有效**，不适用于尚未存入云端的对象。

`query` 选项在有多个客户端需要更新同一属性的时候非常有用。相比于通过 `{{ baseQueryClassName }}` 查询 `{{ baseObjectName }}` 再对其进行更新的方法，这样做更加简洁，并且能够避免出现差错。
{% endif %}

#### 更新计数器

设想我们正在开发一个微博，需要统计一条微博有多少个赞和多少次转发。由于赞和转发的操作可能由多个客户端同时进行，直接在本地更新数字并保存到云端的做法极有可能导致差错。为保证计数的准确性，可以通过 **原子操作** 来增加或减少一个属性内保存的数字：


{% if platform_name === "JavaScript" %}
```js
post.increment('likes', 1);
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
post.update({ likes: db.op.increment(1) });
```
{% endif %}
{% if platform_name === "Python" %}
```python
post.increment('likes', 1)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$post->increment("likes", 1);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
try post.increase("likes", by: 1)
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
post.increment('likes',1);
```
{% endif %}

{% if platform_name === "Go" %}
```go
leancloud.OpIncrement(1)
```
{% endif %}
可以指定需要增加或减少的值。若未指定，则默认使用 `1`。

注意，虽然原子增减支持浮点数，但因为底层数据库的浮点数存储格式限制，会有舍入误差。
因此，需要原子增减的字段建议使用整数以避免误差，例如 `3.14` 可以存储为 `314`，然后在客户端进行相应的转换。
否则，以比较大小为条件查询对象的时候，需要特殊处理，
`< a` 需改查 `< a + e`，`> a` 需改查 `> a - e`，`== a` 需改查 `> a - e` 且 `< a + e`，其中 `e` 为误差范围，据所需精度取值，比如 `0.0001`。

#### 更新数组

更新数组也是原子操作。使用以下方法可以方便地维护数组类型的数据：


{% if platform_name === "JavaScript" %}
- `AV.Object.add('arrayKey', value)`<br/>将指定对象附加到数组末尾。
- `AV.Object.addUnique('arrayKey', value)`<br/>如果数组中不包含指定对象，则将该对象加入数组。对象的插入位置是随机的。
- `AV.Object.remove('arrayKey', value)`<br/>从数组字段中删除指定对象的所有实例。
{% endif %}
{% if platform_name === "JavaScript(next)" %}
- `db.op.add`<br/>将指定对象附加到数组末尾。
- `db.op.addUnique`<br/>如果数组中不包含指定对象，则将该对象加入数组。对象的插入位置是随机的。
- `db.op.remove`<br/>从数组字段中删除指定对象的所有实例。
{% endif %}
{% if platform_name === "Python" %}
- `add()`<br/>将指定对象附加到数组末尾。
- `add_unique()`<br/>如果数组中不包含指定对象，则将该对象加入数组。对象的插入位置是随机的。
- `remove()`<br/>从数组字段中删除指定对象的所有实例。
{% endif %}
{% if platform_name === "PHP" %}
- `addIn()`<br/>将指定对象附加到数组末尾。
- `addUniqueIn()`<br/>如果数组中不包含指定对象，则将该对象加入数组。对象的插入位置是随机的。
- `removeIn()`<br/>从数组字段中删除指定对象的所有实例。
{% endif %}

{% if platform_name === "Swift" %}
- `append(String, element: LCValue)`<br/>将指定对象附加到数组末尾。
- `append(String, element: LCValue, unique: Bool)`<br/>将指定对象附加到数组末尾，并且可以设置一个 `unique` 的 `bool` 值表示只是确保唯一，不会重复添加。
- `append(String, elements: [LCValue])`<br/>将指定对象数组附加到数组末尾。
- `append(String, elements: [LCValue], unique: Bool)`<br/>将指定对象数组附加到数组末尾，并且可以设置一个 `unique` 的 `bool` 值表示只是确保唯一，不会重复添加。
- `remove(String, element: LCValue)`<br/>从数组字段中删除指定对象的所有实例。
- `remove(String, elements: [LCValue])`<br/>从数组对象中删除指定数组中的所有对象。
{% endif %}
{% if platform_name === "Flutter" %}
- `add(key, value)`<br/>将指定对象附加到数组末尾。
- `addAll(key, values)`<br/>将一组对象附加到数组末尾。
- `addUnique(key, value)`<br/>将指定对象附加到数组末尾，确保对象唯一。
- `addAllUnique(key, values)`<br/>将指定对象数组附加到数组末尾，确保对象唯一。
- `remove(key, value)`<br/>从数组字段中删除指定对象的所有实例。
- `removeAll(key, values)`<br/>从数组对象中删除指定数组中的所有对象。
{% endif %}

{% if platform_name === "Go" %}
- `OpAdd(value)`<br/>将指定对象附加到数组末尾。
- `OpAddUnique(value)`<br/>将指定对象附加到数组末尾，确保对象唯一。
- `OpRemove(value)`<br/>从数组字段中删除指定对象的所有实例。
{% endif %}
例如，`Todo` 用一个 `alarms` 属性保存所有闹钟的时间。下面的代码将多个时间加入这个属性：


{% if platform_name === "JavaScript" %}
```js
const alarm1 = new Date('2018-04-30T07:10:00');
const alarm2 = new Date('2018-04-30T07:20:00');
const alarm3 = new Date('2018-04-30T07:30:00');

const alarms = [alarm1, alarm2, alarm3];

const todo = new AV.Object('Todo');
todo.addUnique('alarms', alarms);
todo.save();
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
const alarm1 = new Date('2018-04-30T07:10:00');
const alarm2 = new Date('2018-04-30T07:20:00');
const alarm3 = new Date('2018-04-30T07:30:00');

db.class('Todo').add({
  alarms: db.op.addUnique([alarm1, alarm2, alarm3]),
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

alarm1 = datetime(2018, 4, 30, 7, 10, 00)
alarm2 = datetime(2018, 4, 30, 7, 20, 00)
alarm3 = datetime(2018, 4, 30, 7, 30, 00)

Todo = leancloud.Object.extend('Todo')
todo = Todo()
todo.add_unique('alarms', alarm1)
todo.add_unique('alarms', alarm2)
todo.add_unique('alarms', alarm3)
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$alarm1 = new \DateTime("2018-04-30 07:10:00");
$alarm2 = new \DateTime("2018-04-30 07:20:00");
$alarm3 = new \DateTime("2018-04-30 07:30:00");

$todo = new LeanObject("Todo");
$todo->addUniqueIn("alarms", $alarm1);
$todo->addUniqueIn("alarms", $alarm2);
$todo->addUniqueIn("alarms", $alarm3);
$todo->save();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
func dateWithString(_ string: String) -> LCDate {
    let dateFormatter = DateFormatter()

    dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
    dateFormatter.locale = Locale(identifier: "en_US_POSIX")

    let date = LCDate(dateFormatter.date(from: string)!)

    return date
}

func testSetArray() {
    do {
        let todo = LCObject(className: "Todo")

        let reminder1 = dateWithString("2018-04-30 07:10:00")
        let reminder2 = dateWithString("2018-04-30 07:20:00")

        try todo.set("reminders", value: [reminder1, reminder2])

        let result = todo.save()
        assert(result.isSuccess)

        let reminder3 = dateWithString("2018-04-30 07:30:00")

        try todo.append("reminders", element: reminder3, unique: true)

        _ = todo.save { result in
            switch result {
            case .success:
                break
            case .failure(error: let error):
                print(error)
            }
        }
    } catch {
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
DateTime alarm1 = DateTime.parse('2018-04-30 07:10:00Z');
DateTime alarm2 = DateTime.parse('2018-04-30 07:20:00Z');
DateTime alarm3 = DateTime.parse('2018-04-30 07:30:00Z');

LCObject todo = LCObject("Todo");
todo.addAllUnique('alarms', [alarm1, alarm2, alarm3]);
await todo.save();
```
{% endif %}

{% if platform_name === "Go" %}
```go
alarm1 := time.Parse("2006-01-02 15:04:05Z", "2018-04-30 07:10:00Z")
alarm2 := time.Parse("2006-01-02 15:04:05Z", "2018-04-30 07:20:00Z")
alarm3 := time.Parse("2006-01-02 15:04:05Z", "2018-04-30 07:30:00Z")

alarms := time.Time{alarm1, alarm2, alarm3}

if ref, err := client.Class("Todo").Create(map[string]interface{}{
    "alarms": leancloud.OpAdd(alarms),
}); err != nil {
    panic(err)
}
```
{% endif %}

### 删除对象

下面的代码从云端删除一个 `Todo` 对象；


{% if platform_name === "JavaScript" %}
```js
const todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.destroy();
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
db.class('Todo').object('582570f38ac247004f39c24b').delete();
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo.create_without_data('582570f38ac247004f39c24b')
todo.destroy()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = LeanObject::create("Todo", "582570f38ac247004f39c24b");
$todo->destroy();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
_ = todo.delete { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCObject todo = LCObject.createWithoutData('Todo', '582570f38ac247004f39c24b');
await todo.delete();
```
{% endif %}

{% if platform_name === "JavaScript" %}
如果只需删除对象的一个属性，可以用 `unset`：

```js
const todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');

// priority 属性会被删除
todo.unset('priority');

// 保存对象
todo.save();
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
如果只需删除对象的一个属性，可以用 `db.op.unset`：

```js
db.class('Todo').object('582570f38ac247004f39c24b').update({
  // priority 属性会被删除
  priority: db.op.unset(),
});
```
{% endif %}
{% if platform_name === "Flutter" %}
如果只需删除对象的一个属性，可以用 `unset`：
```dart
LCObject todo = LCObject.createWithoutData('Todo', '582570f38ac247004f39c24b');

// priority 属性会被删除
todo.unset('priority');

// 保存对象
await todo.save();
```
{% endif %}

{% if platform_name === "Go" %}
```go
if err := client.Class("Todo").ID("582570f38ac247004f39c24b").Destroy(); err != nil {
    panic(err)
}
```
{% endif %}

注意，删除对象是一个较为敏感的操作，我们建议你阅读《ACL 权限管理开发指南》来了解潜在的风险。熟悉 class 级别、对象级别和字段级别的权限可以帮助你有效阻止未经授权的操作。

{% if platform_name !== "Go" %}
### 批量操作

{% if platform_name === "JavaScript(next)" %}
可以在一次请求中包含多个创建、更新、删除对象的操作：
{% else %}
可以在一次请求中包含多个构建、保存、删除和同步对象的操作：
{% endif %}


{% if platform_name === "JavaScript" %}
```js
// 创建一个保存所有 AV.Object 的数组
const object1 = new AV.Object("Todo");
object1.set("content", "更新文档");
const object2 = new AV.Object("Todo");
object2.set("content", "回复论坛帖子");
const objects = [object1, object2];

// 批量构建和更新
AV.Object.saveAll(objects).then(
  function (savedObjects) {
    // 成功保存所有对象时进入此 resolve 函数，savedObjects 是包含所有 AV.Object 的数组
  },
  function (error) {
    // 只要有一个对象保存错误就会进入此 reject 函数
  }
);

// 批量删除
AV.Object.destroyAll(objects).then(
  function (deletedObjects) {
    // 成功删除所有对象时进入此 resolve 函数，deletedObjects 是包含所有的 AV.Object 的数组
  },
  function (error) {
    // 只要有一个对象删除错误就会进入此 reject 函数
  }
);

// 批量同步
AV.Object.fetchAll(objects).then(
  function (fetchedObjects) {
    // 成功同步所有对象时进入此 resolve 函数，fetchedObjects 是包含所有的 AV.Object 的数组
  },
  function (error) {
    // 只要有一个对象同步错误就会进入此 reject 函数
  }
);
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
const pipeline = db.pipeline();

pipeline.add('Todo', {
  // ...
});

pipeline.delete('Todo', '5f30ef3fdadca600082ea8e2');

pipeline.get('Todo', '582570f38ac247004f39c24b');

pipeline.commit();
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 批量构建和更新
leancloud.Object.save_all(list_of_objects)

# 批量删除
leancloud.Object.destroy_all(list_of_objects)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 批量构建和更新
LeanObject::saveAll()

// 批量删除
LeanObject::destroyAll()

// 批量同步
LeanObject::fetchAll()
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
// 创建一个保存所有 LCObject 的数组
let objects: [LCObject] = []

// 批量构建和更新
_ = LCObject.save(objects, completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})

// 批量删除
_ = LCObject.delete(objects, completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})

// 批量同步
_ = LCObject.fetch(objects, completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
// 批量构建和更新
LCObject.saveAll();

// 批量删除
LCObject.deleteAll();

// 批量同步
LCObject.fetchAll();
```
{% endif %}

下面的代码将所有 `Todo` 的 `isComplete` 设为 `true`：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
query.find().then((todos) => {
  // 获取需要更新的 todo
  todos.forEach((todo) => {
    // 更新属性值
    todo.set('isComplete', true);
  });
  // 批量更新
  AV.Object.saveAll(todos);
});
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
const pipeline = db.pipeline();
db.class('Todo')
  .find()
  .then((todos) => {
    todos.forEach((todo) => {
      pipeline.update(todo, { isComplete: true });
    });
    return pipeline.commit();
  });
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
# 获取需要更新的 todo
todo1 = Todo()
todo2 = Todo()
todo3 = Todo()
# 更新属性值
todo1.set('isComplete', True)
todo2.set('isComplete', True)
todo3.set('isComplete', True)
# 批量更新
Todo.save_all([todo1, todo2, todo3])
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$todos = $query->find();
// 获取需要更新的 todo
forEach ($todos as $todo) {
    // 更新属性值
    $todo->set("isComplete", true);
}
// 批量更新
LeanObject::saveAll($todos);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
_ = query.find { (result) in
    switch result {
    case .success(objects: let todos):
        // 获取需要更新的 todo
        for todo in todos {
            do {
                // 更新属性值
                try todo.set("isComplete", value: true)
            } catch {
                print(error)
            }
        }
        // 批量更新
        let _ = LCObject.save(todos, completion: { (result) in
            switch result {
            case .success:
                break
            case .failure(error: let error):
                print(error)
            }
        })
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Todo');
List<LCObject> results = await query.find();
// 获取需要更新的 todo
for (LCObject todo in results) {
  // 更新属性值
  todo['isComplete'] = true;
}
await LCObject.saveAll(results);
```
{% endif %}


虽然上述方法可以在一次请求中包含多个操作，每一个分别的保存或同步操作在计费时依然会被算作一次请求，而所有的删除操作则会被合并为一次请求。
{% endif %}
{% if platform_name === "Objective-C" or platform_name === "Android / Java" or platform_name === "Swift" %}
### 后台运行

细心的开发者已经发现，在所有的示例代码中几乎都是用了异步来访问云端，形如{% if platform_name === "Swift" %}下面{% endif %}的用法都是提供给开发者在主线程调用用以实现后台运行的方法，因此开发者在主线程可以放心地调用这种命名方式的函数。

{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo")

_ = todo.save { result in
    switch result {
    case .success:
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "Android / Java" %}
### 离线存储对象

大多数保存功能可以立刻执行，并通知应用「保存完毕」。不过若不需要知道保存完成的时间，则可使用 `saveEventually` 来代替。

它的优点在于：如果用户目前尚未接入网络，`saveEventually` 会缓存设备中的数据，并在网络连接恢复后上传。如果应用在网络恢复之前就被关闭了，那么当它下一次打开时，SDK 会再次尝试保存操作。

所有 `saveEventually`（或 `deleteEventually`）的相关调用，将按照调用的顺序依次执行。因此，多次对某一对象使用 `saveEventually` 是安全的。
{% endif %}

### 数据模型

对象之间可以产生关联。拿一个博客应用来说，一个 `Post` 对象可以与许多个 `Comment` 对象产生关联。云服务支持三种关系：一对一、一对多、多对多。

#### 一对一、一对多关系

一对一、一对多关系可以通过将 `{{ baseObjectName }}` 保存为另一个对象的属性值的方式产生。比如说，让博客应用中的一个 `Comment` 指向一个 `Post`。

下面的代码会创建一个含有单个 `Comment` 的 `Post`：


{% if platform_name === "JavaScript" %}
```js
// 创建 post
const post = new AV.Object('Post');
post.set('title', '饿了……');
post.set('content', '中午去哪吃呢？');

// 创建 comment
const comment = new AV.Object('Comment');
comment.set('content', '当然是肯德基啦！');

// 将 post 设为 comment 的一个属性值
comment.set('parent', post);

// 保存 comment 会同时保存 post
comment.save();
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
db.class('Post')
  .add({
    title: '饿了……',
    content: '中午去哪吃呢？',
  })
  .then((post) => {
    return db.class('Comment').add({
      post, // 将 post 设为 comment 的一个属性值
      content: '当然是肯德基啦！',
    });
  });
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 创建 post
Post = leancloud.Object.extend('Post')
post = Post()
post.set('title', '饿了……')
post.set('content', '中午去哪吃呢？')

# 创建 comment
Comment = leancloud.Object.extend('Comment')
comment = Comment()
comment.set('content', '当然是肯德基啦！')

# 将 post 设为 comment 的一个属性值
comment.set('parent', post)

# 保存 comment 会同时保存 post
comment.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 创建 post
$post = new LeanObject("Post");
$post->set("title", "饿了……");
$post->set("content", "中午去哪吃呢？");

// 创建 comment
$comment = new LeanObject("Comment");
$comment->set("content", "当然是肯德基啦！")

// 将 post 设为 comment 的一个属性值
$comment->set("parent", $post)

// 保存 comment 会同时保存 post
$comment->save();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
do {
    // 创建 post
    let post = LCObject(className: "Post")
    try post.set("title", value: "饿了……")
    try post.set("content", value: "中午去哪吃呢？")

    // 创建 comment
    let comment = LCObject(className: "Comment")
    try comment.set("content", value: "当然是肯德基啦！")

    // 将 post 设为 comment 的一个属性值
    try comment.set("parent", value: post)

    // 保存 comment 会同时保存 post
    assert(comment.save().isSuccess)
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
// 创建 post
LCObject post = LCObject("Post");
post['title'] = '饿了……';
post['content'] = '中午去哪吃呢?';

// 创建 comment
LCObject comment = LCObject("Comment");
comment['content'] = '当然是肯德基啦!';

// 将 post 设为 comment 的一个属性值
comment['parent'] = post;

// 保存 comment 会同时保存 post
await comment.save();
```
{% endif %}

{% if platform_name === "Go" %}
```go
type Post struct {
    leancloud.Object
    Title   string `json:"title"`
    Content string `json:"content"`
}

type Comment struct {
    leancloud.Object
    Parent  Post   `json:"parent"` // 嵌入自定义结构体
    Content string `json:"content"`
}

post := Post{
    Title: "饿了……",
    Content: "中午去哪吃呢？",
}

if ref, err := client.Class("Post").Create(&post); err != nil {
    panic(err)
}

comment := Comment{
    Parent: post, //  嵌入已有的对象
    Content: "当然是肯德基啦！",
}

if ref, err := client.Class("Comment").Create(&comment); err != nil {
    panic(err)
}
```
注意：**只有已经保存到云端的对象可以嵌入。**
{% endif %}

{% if platform_name !== "Go" %}
云端存储时，会将被指向的对象用 `Pointer` 的形式存起来。你也可以用 `objectId` 来指向一个对象：
{% endif %}


{% if platform_name === "JavaScript" %}
```js
const post = AV.Object.createWithoutData('Post', '57328ca079bc44005c2472d0');
comment.set('post', post);
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
db.class('Comment').add({
  post: db.class('Post').object('57328ca079bc44005c2472d0'),
  content: '当然是肯德基啦！',
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Post = leancloud.Object.extend('Post')
post = Post.create_without_data('57328ca079bc44005c2472d0')
comment.set('post', post)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$post = LeanObject::create("Post", "57328ca079bc44005c2472d0")
$comment->set("post", $post)
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let post = LCObject(className: "Post", objectId: "57328ca079bc44005c2472d0")
try comment.set("post", value: post)
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCObject post = LCObject.createWithoutData('Post', '57328ca079bc44005c2472d0');
comment['post'] = post;
```
{% endif %}


请参阅 [关系查询](#关系查询) 来了解如何获取关联的对象。

#### 多对多关系

想要建立多对多关系，最简单的办法就是使用 **数组**。在大多数情况下，使用数组可以有效减少查询的次数，提升程序的运行效率。但如果有额外的属性需要附着于两个 class 之间的关联，那么使用 **中间表** 可能是更好的方式。注意这里说到的额外的属性是用来描述 class 之间的关系的，而不是任何单一的 class 的。

我们建议你在任何一个 class 的对象数量超出 100 的时候考虑使用中间表。

{% if platform_name in ["Objective-C", "JavaScript", "JavaScript(next)", "Android / Java", "Swift", "Flutter", ".Net"] %}
### 序列化和反序列化

在实际的开发中，把 `{{ baseObjectName }}` 当作参数传递的时候，会涉及到复杂对象的拷贝的问题，因此 `{{ baseObjectName }}` 也提供了序列化和反序列化的方法。

序列化：


{% if platform_name === "JavaScript" %}
```js
const todo = new AV.Object('Todo'); // 构建对象
todo.set('title', '马拉松报名'); // 设置名称
todo.set('priority', 2); // 设置优先级
todo.set('owner', AV.User.current()); // 这里就是一个 Pointer 类型，指向当前登录的用户

// 将 AV.Object 对象序列化成 JSON 对象
const json = todo.toFullJSON();
// 将 JSON 对象序列化为字符串
const serializedString = JSON.stringify(json);
```

`AV.Object` 还提供了另一个方法 `toJSON()`。它们的区别是 `toJSON()` 得到的对象仅包含对象的 payload，一般用于展示，而 `toFullJSON()` 得到的对象包含了元数据，一般用于传输。在使用时请注意区分。
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
// 将 LCObject 对象序列化成 JSON 对象
const json = db.encode(todo);
// 将 JSON 对象序列化为字符串
const serializedString = JSON.stringify(json);
```

`LCObject` 还提供了一个方法 `toJSON()`。它们的区别是 `toJSON()` 得到的对象仅包含对象的 payload，一般用于展示，而 `db.encode` 得到的对象包含了元数据，一般用于传输。在使用时请注意区分。
{% endif %}

{% if platform_name === "Swift" %}
```swift
do {
    let todo = LCObject(className: "Todo")

    try todo.set("title", value: "马拉松报名")
    try todo.set("priority", value: 2)
    try todo.set("owner", value: LCApplication.default.currentUser)

    let data: Data
    if #available(iOS 11.0, *) {
        data = try NSKeyedArchiver.archivedData(withRootObject: todo, requiringSecureCoding: false)
    } else {
        data = NSKeyedArchiver.archivedData(withRootObject: todo)
    }
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCObject object = LCObject('Hello');
object['title'] = '马拉松报名';
object['priority'] = 2;
object['owner'] = LCUser.getCurrent();
String serializedString = object.toString();
```
{% endif %}


反序列化：


{% if platform_name === "JavaScript" %}
```js
// 将字符串反序列化为 JSON 对象
const json = JSON.parse(serializedString);
// 将 JSON 对象反序列化成 AV.Object 对象
const todo = AV.parseJSON(json);
```
{% endif %}
{% if platform_name === "JavaScript(next)" %}
```js
// 将字符串反序列化为 JSON 对象
const json = JSON.parse(serializedString);
// 将 JSON 对象反序列化成 LCObject 对象
const todo = db.decode(json);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
do {
    let todo = LCObject(className: "Todo")

    try todo.set("title", value: "马拉松报名")
    try todo.set("priority", value: 2)
    try todo.set("owner", value: LCApplication.default.currentUser)

    let data: Data
    if #available(iOS 11.0, *) {
        data = try NSKeyedArchiver.archivedData(withRootObject: todo, requiringSecureCoding: false)
    } else {
        data = NSKeyedArchiver.archivedData(withRootObject: todo)
    }

    let newTodo: LCObject? = try NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(data) as? LCObject
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCObject newObject = LCObject.parseObject(json);
await newObject.save();
```
{% endif %}

{% endif %}

{% if platform_name === "Python" %}
### 线程安全

`leancloud.Object` 目前不是线程安全的，因此请避免多个线程修改同一个 `leancloud.Object` 实例的操作。如果遇到必须多线程操作的情况，需要根据情况加锁。
{% endif %}

## 查询

我们已经了解到如何从云端获取单个 `{{ baseObjectName }}`，但你可能还会有一次性获取多个符合特定条件的 `{{ baseObjectName }}` 的需求，这时候就需要用到 `{{ baseQueryClassName }}` 了。

### 基础查询

执行一次基础查询通常包括这些步骤：

1. 构建 `{{ baseQueryClassName }}`；
2. 向其添加查询条件；
3. 执行查询并获取包含满足条件的对象的数组。

下面的代码获取所有 `lastName` 为 `Smith` 的 `Student`：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Student');
query.equalTo('lastName', 'Smith');
query.find().then((students) => {
  // students 是包含满足条件的 Student 对象的数组
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Student = leancloud.Object.extend('Student')
query = Student.query
# 以上两行等价于 query = leancloud.Query('Student')
query.equal_to('lastName', 'Smith')
student_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Student");
$query->equalTo("lastName", "Smith");
$students = $query->find();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Student")
query.whereKey("lastName", .equalTo("Smith"))
_ = query.find { result in
    switch result {
    case .success(objects: let students):
        // students 是包含满足条件的 Student 对象的数组
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Student');
query.whereEqualTo('lastName', 'Smith');
// students 是包含满足条件的 Student 对象的数组
List<LCObject> students = await query.find();
```
{% endif %}

{% if platform_name === "Go" %}
```go
type Student struct {
    leancloud.Object
    FirstName string `json:"firstName"`
    LastName  string `json:"lastName"`
}

results := make([]Student, 0)

if err := client.Class("Student").NewQuery().EqualTo("lastName", "Smith").Find(&results); err != nil {
    panic(err)
}
```

注意：查询条件中指定的字段为 **云端的字段名** 而不是 结构体的字段名。

{% endif %}
### 查询条件

可以给 `{{ baseObjectName }}` 添加不同的条件来改变获取到的结果。

下面的代码查询所有 `firstName` 不为 `Jack` 的对象：


{% if platform_name === "JavaScript" %}
```js
query.notEqualTo('firstName', 'Jack');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.not_equal_to("firstName", 'Jack')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->notEqualTo("firstName", "Jack");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
query.whereKey("firstName", .notEqualTo("Jack"))
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
query.whereNotEqualTo('firstName', 'Jack');
```
{% endif %}

{% if platform_name === "Go" %}
```go
query := client.Class("Student").NewQuery().NotEqualTo("firstName", "Jack")
```
{% endif %}
对于能够排序的属性（比如数字、字符串），可以进行比较查询：


{% if platform_name === "JavaScript" %}
```js
// 限制 age < 18
query.lessThan('age', 18);

// 限制 age <= 18
query.lessThanOrEqualTo('age', 18);

// 限制 age > 18
query.greaterThan('age', 18);

// 限制 age >= 18
query.greaterThanOrEqualTo('age', 18);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 限制 age < 18
query.less_than('age', 18)

# 限制 age <= 18
query.less_than_or_equal_to('age', 18)

# 限制 age > 18
query.greater_than('age', 18)

# 限制 age >= 18
query.greater_than_or_equal_to('age', 18)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 限制 age < 18
$query->lessThan("age", 18);

// 限制 age <= 18
$query->lessThanOrEqualTo("age", 18);

// 限制 age > 18
$query->greaterThan("age", 18);

// 限制 age >= 18
$query->greaterThanOrEqualTo("age", 18);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
// 限制 age < 18
query.whereKey("age", .lessThan(18));

// 限制 age <= 18
query.whereKey("age", .lessThanOrEqualTo(18));

// 限制 age > 18
query.whereKey("age", .greaterThan(18));

// 限制 age >= 18
query.whereKey("age", .greaterThanOrEqualTo(18));
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
// 限制 age < 18
query.whereLessThan('age', 18);

// 限制 age <= 18
query.whereLessThanOrEqualTo('age', 18);

// 限制 age > 18
query.whereGreaterThan('age', 18);

// 限制 age >= 18
query.whereGreaterThanOrEqualTo('age', 18);
```
{% endif %}

{% if platform_name === "Go" %}
```go
// 限制 age < 18
query := client.Class("Student").NewQuery().LessThan("age", 18)

// 限制 age <= 18
query := client.Class("Student").NewQuery().LessThanOrEqualTo("age", 18)

// 限制 age > 18
query := client.Class("Student").NewQuery().GreaterThan("age", 18)

// 限制 age >= 18
query := client.Class("Student").NewQuery().GreaterThanOrEqualTo("age", 18)
```
{% endif %}
可以在同一个查询中设置多个条件，这样可以获取满足所有条件的结果。可以理解为所有的条件是 `AND` 的关系：


{% if platform_name === "JavaScript" %}
```js
query.equalTo('firstName', 'Jack');
query.greaterThan('age', 18);
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.equal_to("firstName", 'Jack')
query.greater_than('age', 18)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->equalTo("firstName", "Jack");
$query->greaterThan("age", 18);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
query.whereKey("firstName", .equalTo("Jack"))
query.whereKey("age", .greaterThan(18))
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
query.whereEqualTo('firstName', 'Jack');
query.whereGreaterThan('age', 18);
```
{% endif %}

{% if platform_name === "Go" %}
```go
query := client.Class("Student").NewQuery().EqualTo("firstName", "Jack").GreaterThan("age", 18)
```
{% endif %}
可以通过指定 `limit` 限制返回结果的数量（默认为 `100`）：


{% if platform_name === "JavaScript" %}
```js
// 最多获取 10 条结果
query.limit(10);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 最多获取 10 条结果
query.limit(10)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 最多获取 10 条结果
$query->limit(10);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
// 最多获取 10 条结果
query.limit = 10
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
// 最多获取 10 条结果
query.limit(10);
```
{% endif %}

{% if platform_name === "Go" %}
```go
// 最多获取 10 条结果
query := client.Class("Student").NewQuery().Limit(10)
```
{% endif %}
由于性能原因，`limit` 最大只能设为 `1000`。即使将其设为大于 `1000` 的数，云端也只会返回 1,000 条结果。

如果只需要一条结果，可以直接用 `{% if platform_name === "JavaScript" %}first{% endif %}{% if platform_name === "Python" %}first{% endif %}{% if platform_name === "PHP" %}{% endif %}{% if platform_name === "Swift" %}getFirst{% endif %}{% if platform_name === "Flutter" %}first{% endif %}{% if platform_name === "Go" %}First{% endif %}`：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
query.equalTo('priority', 2);
query.first().then((todo) => {
  // todo 是第一个满足条件的 Todo 对象
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.equal_to('priority', 2)
todo = query.first()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->equalTo("priority", 2);
$todo = $query->first();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("priority", .equalTo(2))
_ = query.getFirst { result in
    switch result {
    case .success(object: let todo):
        print(todo)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Todo');
query.whereEqualTo('priority', 2);
// todo 是第一个满足条件的 Todo 对象
LCObject todo = await query.first();
```
{% endif %}

{% if platform_name === "Go" %}
```go
todo := new(Todo)

if err := client.Class("Todo").NewQuery().EqualTo("priority", 2).First(todo); err != nil {
    panic(err)
} 
```
{% endif %}
可以通过设置 `skip` 来跳过一定数量的结果：


{% if platform_name === "JavaScript" %}
```js
// 跳过前 20 条结果
query.skip(20);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 跳过前 20 条结果
query.skip(20)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 跳过前 20 条结果
$query->skip(20);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
// 跳过前 20 条结果
query.skip = 20
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
query.skip(20);
```
{% endif %}

{% if platform_name === "Go" %}
```go
query := client.Class("Todo").NewQuery().Skip(20)
```
{% endif %}
把 `skip` 和 `limit` 结合起来，就能实现翻页功能：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
query.equalTo('priority', 2);
query.limit(10);
query.skip(20);
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.equal_to('priority', 2)
query.limit(10)
query.skip(20)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->equalTo("priority", 2);
$query->limit(10);
$query->skip(20);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("priority", .equalTo(2))
query.limit = 10
query.skip = 20
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Todo');
query.whereEqualTo('priority', 2);
query.limit(10);
query.skip(20);
```
{% endif %}

{% if platform_name === "Go" %}
```go
query := client.Class("Todo").NewQuery().EqualTo("priority", 2).Limit(10).Skip(20)
```
{% endif %}
需要注意的是，`skip` 的值越高，查询所需的时间就越长。作为替代方案，可以通过设置 `createdAt` 或 `updatedAt` 的范围来实现更高效的翻页，因为它们都自带索引。
同理，也可以通过设置自增字段的范围来实现翻页。

对于能够排序的属性，可以指定结果的排序规则：


{% if platform_name === "JavaScript" %}
```js
// 按 createdAt 升序排列
query.ascending('createdAt');

// 按 createdAt 降序排列
query.descending('createdAt');
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 按 createdAt 升序排列
query.ascending('createdAt')

# 按 createdAt 降序排列
query.descending('createdAt')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 按 createdAt 升序排列
$query->ascend("createdAt");

// 按 createdAt 降序排列
$query->descend("createdAt");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
// 按 createdAt 升序排列
query.whereKey("createdAt", .ascending)

// 按 createdAt 降序排列
query.whereKey("createdAt", .descending)
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
// 按 createdAt 升序排列
query.orderByAscending('createdAt');

// 按 createdAt 降序排列
query.orderByDescending('createdAt');
```
{% endif %}

{% if platform_name === "Go" %}
```go
// 按 createdAt 升序排列
query := client.Class("Todo").NewQuery().Order("createdAt")

// 按 createdAt 降序排列
query := client.Class("Todo").NewQuery().Order("-createdAt")
```
{% endif %}
还可以为同一个查询添加多个排序规则；


{% if platform_name === "JavaScript" %}
```js
query.addAscending('priority');
query.addDescending('createdAt');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.add_ascending('createdAt')
query.add_descending('priority')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->addAscend("priority");
$query->addDescend("createdAt");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
query.whereKey("priority", .ascending)
query.whereKey("createdAt", .descending)
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
query.addAscendingOrder('priority');
query.addDescendingOrder('createdAt');
```
{% endif %}

{% if platform_name === "Go" %}
```go
query := client.Class("Todo").NewQuery().Order("priority").Order("-createdAt")
```
{% endif %}
下面的代码可用于查找包含或不包含某一属性的对象：

{% if platform_name === "Go" %}
```go
// 查找包含 "image" 的对象
query := client.Class("Todo").NewQuery().Exists("image")

// 查找不包含 "image" 的对象
query := client.Class("Todo").NewQuery().NotExists("image")
```
{% endif  %}

{% if platform_name === "JavaScript" %}
```js
// 查找包含 'images' 的对象
query.exists('images');

// 查找不包含 'images' 的对象
query.doesNotExist('images');
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 查找包含 'images' 的对象
query.exists('images')

# 查找不包含 'images' 的对象
query.does_not_exist('images')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 查找包含 "images" 的对象
$query->exists("images");

// 查找不包含 "images" 的对象
$query->notExists("images");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
// 查找包含 "images" 的对象
query.whereKey("images", .existed)

// 查找不包含 "images" 的对象
query.whereKey("images", .notExisted)
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
// 查找包含 'images' 的对象
query.whereExists('images');

// 查找不包含 'images' 的对象
query.whereDoesNotExist('images');
```
{% endif %}


{% if platform_name === "JavaScript" %}
可以用 `matchesKeyInQuery` 查找某一属性值为另一查询返回结果的对象。

比如说，你有一个用于存储国家和语言对应关系的 `Country` class，还有一个用于存储学生国籍的 `Student` class：

name | language
--- | ---
US | English
UK | English
China | Chinese

fullName | nationality
--- | ---
John Doe | US
Tom Sawyer | UK
Ming Li | China

下面的代码可以找到所有来自英语国家的学生：

```js
const studentQuery = new AV.Query('Student');
const countryQuery = new AV.Query('Country');
// 获取所有的英语国家
countryQuery.equalTo('language', 'English');
// 把 Student 的 nationality 和 Country 的 name 关联起来
studentQuery.matchesKeyInQuery('nationality', 'name', countryQuery);
studentQuery.find().then((students) => {
  // students 包含 John Doe 和 Tom Sawyer
});
```
{% endif %}

可以通过 `{% if platform_name === "JavaScript" %}select{% endif %}{% if platform_name === "Python" %}select{% endif %}{% if platform_name === "PHP" %}select{% endif %}{% if platform_name === "Swift" %}.selected{% endif %}{% if platform_name === "Go"%}Select{% endif %}` 指定需要返回的属性。下面的代码只获取每个对象的 `title` 和 `content`（包括内置属性 `objectId`、`createdAt` 和 `updatedAt`）：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
query.select(['title', 'content']);
query.first().then((todo) => {
  const title = todo.get('title'); // √
  const content = todo.get('content'); // √
  const notes = todo.get('notes'); // undefined
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.select('title', 'content')
todo = query.first()

title = todo.get('title') # √
content = todo.get('content') # √
notes = todo.get('notes') # None
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->select("title", "content");
$todo = $query->first();

$title = $todo->get("title"); // √
$content = $todo->get("content"); // √
$notes = $todo->get("notes"); // null
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("title", .selected)
query.whereKey("content", .selected)
_ = query.getFirst { result in
    switch result {
    case .success(object: let todo):
        let title = todo.get("title") // √
        let content = todo.get("content") // √
        let notes = todo.get("notes") // nil
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Todo');
query.select('title');
query.select('content');
LCObject todo = await query.first();

String title = todo['title']; // √
String content = todo['content']; // √
String notes = todo['notes']; // null
```
{% endif %}

{% if platform_name === "Go" %}
```go
todos := make([]Todo, 0)

if err := client.Class("Todo").NewQuery().Select("title", "content").Find(&todo); err != nil {
    panic(err)
}
```
{% endif %}
`{% if platform_name === "JavaScript" %}select{% endif %}{% if platform_name === "Python" %}select{% endif %}{% if platform_name === "PHP" %}select{% endif %}{% if platform_name === "Swift" %}.selected{% endif %}{% if platform_name === "Go" %}Select{% endif %}`
支持点号（`author.firstName`），详见《点号使用指南》。
另外，字段名前添加减号前缀表示反向选择，例如 `-author` 表示不返回 `author` 字段。
反向选择同样适用于内置字段，比如 `-objectId`，也可以和点号组合使用，比如 `-pubUser.createdAt`。

{% if platform_name !== "Go" %}
{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Java" or platform_name === "Swift" %}
对于未获取的属性，可以通过对结果中的对象进行 `{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Python" %}fetch{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}` 操作来获取。参见 [同步对象](#同步对象)。
{% endif %}
{% endif %}
### 字符串查询

可以用 `{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Python" %}startswith{% endif %}{% if platform_name === "PHP" %}startsWith{% endif %}{% if platform_name === "Swift" %}.prefixedBy{% endif %}{% if platform_name === "Go" %}Query.StartsWith{% endif %}` 来查找某一属性值以特定字符串开头的对象。和 SQL 中的 `LIKE` 一样，你可以利用索引带来的优势：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
// 相当于 SQL 中的 title LIKE 'lunch%'
query.startsWith('title', 'lunch');
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
# 相当于 SQL 中的 title LIKE 'lunch%'
query.startswith("title", "lunch")
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
// 相当于 SQL 中的 title LIKE 'lunch%'
$query->startsWith("title", "lunch");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
// 相当于 SQL 中的 title LIKE 'lunch%'
query.whereKey("title", .prefixedBy("lunch"))
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = new LCQuery('Todo');
// 相当于 SQL 中的 title LIKE 'lunch%'
query.whereStartsWith('title', 'lunch');
```
{% endif %}

{% if platform_name === "Go" %}
```go
// 相当于 SQL 中的 title LIKE 'lunch%'
query := client.Class("Todo").NewQuery().StartsWith("title", "lunch")
```
{% endif %}

可以用 `{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Python" %}contains{% endif %}{% if platform_name === "PHP" %}contains{% endif %}{% if platform_name === "Swift" %}.matchedSubstring{% endif %}{% if platform_name === "Go" %}Query.Contains{% endif %}` 来查找某一属性值包含特定字符串的对象：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
// 相当于 SQL 中的 title LIKE '%lunch%'
query.contains('title', 'lunch');
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
# 相当于 SQL 中的 title LIKE '%lunch%'
query.contains("title", "lunch")
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
// 相当于 SQL 中的 title LIKE '%lunch%'
$query->contains("title", "lunch");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
// 相当于 SQL 中的 title LIKE '%lunch%'
query.whereKey("title", .matchedSubstring("lunch"))
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Todo');
// 相当于 SQL 中的 title LIKE '%lunch%'
query.whereContains('title', 'lunch');
```
{% endif %}

{% if platform_name === "Go" %}
```go
// 相当于 SQL 中的 title LIKE '%lunch%'
query := client.Class("Todo").NewQuery().Contains("title", "lunch")
```
{% endif %}

和 `{% if platform_name === "Go" %}Query.StartsWith{% endif %}{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Python" %}startswith{% endif %}{% if platform_name === "PHP" %}startsWith{% endif %}{% if platform_name === "Swift" %}.prefixedBy{% endif %}{% if platform_name === "Flutter" %}whereStartsWith{% endif %}` 不同，`{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Python" %}contains{% endif %}{% if platform_name === "PHP" %}contains{% endif %}{% if platform_name === "Swift" %}.matchedSubstring{% endif %}{% if platform_name === "Flutter" %}whereContains{% endif %}{% if platform_name === "Go" %}Query.Contains{% endif %}` 无法利用索引，因此不建议用于大型数据集。

注意 `{% if platform_name === "Go" %}Query.StartsWith{% endif %}{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Python" %}startswith{% endif %}{% if platform_name === "PHP" %}startsWith{% endif %}{% if platform_name === "Swift" %}.prefixedBy{% endif %}{% if platform_name === "Flutter" %}whereStartsWith{% endif %}` 和 `{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Python" %}contains{% endif %}{% if platform_name === "PHP" %}contains{% endif %}{% if platform_name === "Swift" %}.matchedSubstring{% endif %}{% if platform_name === "Flutter" %}whereContains{% endif %}` 都是 **区分大小写** 的，所以上述查询会忽略 `Lunch`、`LUNCH` 等字符串。

如果想查找某一属性值不包含特定字符串的对象，可以使用 `{% if platform_name === "Go" %}Query.Regexp{% endif %}{% if platform_name === "JavaScript" %}matches{% endif %}{% if platform_name === "Python" %}matched{% endif %}{% if platform_name === "PHP" %}matches{% endif %}{% if platform_name === "Swift" %}.matchedPattern{% endif %}{% if platform_name === "Flutter" %}whereMatches{% endif %}` 进行基于正则表达式的查询：


{% if platform_name === "JavaScript" %}
<pre><code class="lang-js">const query = new AV.Query('Todo');
// 'title' 不包含 'ticket'（不区分大小写）
const regExp = new RegExp('{{ regex(true) | safe }}, 'i');
query.matches('title', regExp);
</code></pre>
{% endif %}
{% if platform_name === "Python" %}
<pre><code class="lang-python">Todo = leancloud.Object.extend('Todo')
query = Todo.query
# 'title' 不包含 'ticket'（不区分大小写）
query.matched('title', '{{ regex(true) | safe }}, ignore_case=True)
</code></pre>
{% endif %}
{% if platform_name === "PHP" %}
<pre><code class="lang-php">$query = new Query("Todo");
// "title" 不包含 "ticket"（不区分大小写）
$query->matches("title", "{{ regex() | safe }}, "i");
</code></pre>
{% endif %}

{% if platform_name === "Swift" %}
<pre><code class="lang-swift">let query = LCQuery(className: "Todo")
// "title" 不包含 "ticket"（不区分大小写）
query.whereKey("title", .matchedRegularExpression("{{ regex() | safe }}, option: "i"))
</code></pre>
{% endif %}
{% if platform_name === "Flutter" %}
<pre><code class="lang-dart">LCQuery query = LCQuery('Todo');
// 'title' 不包含 "ticket"（不区分大小写）
query.whereMatches('title', '{{ regexFlutter() | safe }}', modifiers: 'i');
</code></pre>
{% endif %}

{% if platform_name === "Go" %}
```go
query := client.Class("Todo").NewQuery().Regexp("title", "^((?!ticket).)*$", "i")
```
{% endif %}
{# 2016-12-29 DO NOT USE markdown to rewrite the previous block #}

不过我们并不推荐大量使用这类查询，尤其是对于包含超过 100,000 个对象的 class，
因为这类查询无法利用索引，实际操作中云端会遍历所有对象来获取结果。如果有进行全文搜索的需求，可以使用全文搜索服务。

使用查询时如果遇到性能问题，可参阅 [查询性能优化](#查询性能优化)。

### 数组查询

下面的代码查找所有数组属性 `tags` 包含 `工作` 的对象：


{% if platform_name === "JavaScript" %}
```js
query.equalTo('tags', '工作');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.equal_to('tags', '工作')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->equalTo("tags", "工作");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
query.whereKey("tags", .equalTo("工作"))
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
query.whereEqualTo('tags', '工作');
```
{% endif %}


下面的代码查询数组属性长度为 3 （正好包含 3 个标签）的对象：


{% if platform_name === "JavaScript" %}
```js
query.sizeEqualTo('tags', 3);
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.size_equal_to('tags', 3)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->sizeEqualTo("tags", 3);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
query.whereKey("tags", .equalToSize(3))
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
query.whereSizeEqualTo('tags', 3);
```
{% endif %}

{% if platform_name === "Go" %}
```go
query := client.Class("Todo").NewQuery().EqualTo("tags", "工作")
```
{% endif %}
下面的代码查找所有数组属性 `tags` **同时包含** `工作`、`销售` 和 `会议` 的对象：


{% if platform_name === "JavaScript" %}
```js
query.containsAll('tags', ['工作', '销售', '会议']);
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.contains_all('tags', ['工作', '销售', '会议'])
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->containsAll("tags", array("工作", "销售", "会议"));
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
query.whereKey("tags", .containedAllIn(["工作", "销售", "会议"]))
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
query.whereContainsAll('tags', ['工作', '销售', '会议']);
```
{% endif %}

{% if platform_name === "Go" %}
```go
query := client.Class("Todo").NewQuery().ContainsAll("tags", []string{"工作", "销售", "会议"})
```
{% endif %}
如需获取某一属性值包含一列值中任意一个值的对象，可以直接用 `{% if platform_name === "JavaScript" %}containedIn{% endif %}{% if platform_name === "Python" %}contained_in{% endif %}{% if platform_name === "PHP" %}containedIn{% endif %}{% if platform_name === "Swift" %}.containedIn{% endif %}` 而无需执行多次查询。下面的代码构建的查询会查找所有 `priority` 为 `1` **或** `2` 的 todo 对象：


{% if platform_name === "JavaScript" %}
```js
// 单个查询
const priorityOneOrTwo = new AV.Query('Todo');
priorityOneOrTwo.containedIn('priority', [1, 2]);
// 这样就可以了 :)

// ---------------
//       vs.
// ---------------

// 多个查询
const priorityOne = new AV.Query('Todo');
priorityOne.equalTo('priority', 1);

const priorityTwo = new AV.Query('Todo');
priorityTwo.equalTo('priority', 2);

const priorityOneOrTwo = AV.Query.or(priorityOne, priorityTwo);
// 好像有些繁琐 :(
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 单个查询
Todo = leancloud.Object.extend('Todo')
priority_one_or_two = Todo.query
priority_one_or_two.contained_in('priority', [1, 2])
# 这样就可以了 :)

# ---------------
#       vs.
# ---------------

# 多个查询
Todo = leancloud.Object.extend('Todo')

priority_one = Todo.query
priority_one.equal_to('priority', 1)

priority_two = Todo.query
priority_two.equal_to('priority', 2)

priority_one_or_two = leancloud.Query.or_(priority_one, priority_two)
# 好像有些繁琐 :(
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 单个查询
$priorityOneOrTwo = new Query("Todo");
$priorityOneOrTwo->containedIn("priority", array(1, 2));
// 这样就可以了 :)

// ---------------
//       vs.
// ---------------

// 多个查询
$priorityOne = new Query("Todo");
$priorityOne->equalTo("priority", 1);

$priorityTwo = new Query("Todo");
$priorityTwo->equalTo("priority", 2);

$query = Query::orQuery($priorityOne, $priorityTwo);
// 好像有些繁琐 :(
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
// 单个查询
let priorityOneOrTwo = LCQuery(className: "Todo")
priorityOneOrTwo.whereKey("priority", .containedIn([1, 2]))
// 这样就可以了 :)

// ---------------
//       vs.
// ---------------

// 多个查询
let priorityOne = LCQuery(className: "Todo")
priorityOne.whereKey("priority", .equalTo(1))

let priorityTwo = LCQuery(className: "Todo")
priorityTwo.whereKey("priority", .equalTo(2))

let priorityOneOrTwo = priorityOne.or(priorityTwo)
// 好像有些繁琐 :(
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
// 单个查询
LCQuery<LCObject> priorityOneOrTwo = LCQuery('Todo');
priorityOneOrTwo.whereContainedIn('priority', [1, 2]);
// 这样就可以了 :)

// ---------------
//       vs.
// ---------------

// 多个查询
LCQuery<LCObject> priorityOne = LCQuery('Todo');
priorityOne.whereEqualTo('priority', 1);

LCQuery<LCObject> priorityTwo = LCQuery('Todo');
priorityTwo.whereEqualTo('priority', 2);

LCQuery<LCObject> priorityOneOrTwo = LCQuery.or([priorityOne, priorityTwo]);
List<LCObject> results = await priorityOneOrTwo.find();
// 好像有些繁琐 :(
```
{% endif %}

{% if platform_name === "Go" %}
```go
// 暂不支持
```
{% endif %}
反过来，还可以用 `{% if platform_name === "JavaScript" %}notContainedIn{% endif %}{% if platform_name === "Python" %}not_contained_in{% endif %}{% if platform_name === "PHP" %}notContainedIn{% endif %}{% if platform_name === "Swift" %}.notContainedIn{% endif %}{% if platform_name === "Flutter" %}whereNotContainedIn{% endif %}` 来获取某一属性值不包含一列值中任何一个的对象。

### 关系查询

查询关联数据有很多种方式，常见的一种是查询某一属性值为特定 `{{ baseObjectName }}` 的对象，这时可以像其他查询一样直接用 `{% if platform_name === "JavaScript" %}equalTo{% endif %}{% if platform_name === "Python" %}equal_to{% endif %}{% if platform_name === "PHP" %}equalTo{% endif %}{% if platform_name === "Swift" %}.equalTo{% endif %}`。比如说，如果每一条博客评论 `Comment` 都有一个 `post` 属性用来存放原文 `Post`，则可以用下面的方法获取所有与某一 `Post` 相关联的评论：


{% if platform_name === "JavaScript" %}
```js
const post = AV.Object.createWithoutData('Post', '57328ca079bc44005c2472d0');
const query = new AV.Query('Comment');
query.equalTo('post', post);
query.find().then((comments) => {
  // comments 包含与 post 相关联的评论
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Post = leancloud.Object.extend('Post')
post = Post.create_without_data('57328ca079bc44005c2472d0')
query = leancloud.Query('Comment')
query.equal_to('post', post)
comment_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$post = LeanObject::create("Post", "57328ca079bc44005c2472d0")
$query = new Query("Comment");
$query->equalTo("post", $post);
$comments = $query->find();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let post = LCObject(className: "Post", objectId: "57328ca079bc44005c2472d0")
let query = LCQuery(className: "Comment")
query.whereKey("post", .equalTo(post))
_ = query.find { result in
    switch result {
    case .success(objects: let comments):
        // comments 包含与 post 相关联的评论
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCObject post = LCObject.createWithoutData('Post', '57328ca079bc44005c2472d0');
LCQuery<LCObject> query = LCQuery('Comment');
query.whereEqualTo('post', post);
// comments 包含与 post 相关联的评论
List<LCObject> comments = await query.find();
```
{% endif %}


如需获取某一属性值为另一查询结果中任一 `{{ baseObjectName }}` 的对象，可以用 `{% if platform_name === "JavaScript" %}matchesQuery{% endif %}{% if platform_name === "Python" %}matches_query{% endif %}{% if platform_name === "PHP" %}matchesInQuery{% endif %}{% if platform_name === "Swift" %}.matchedQuery{% endif %}`。下面的代码构建的查询可以找到所有包含图片的博客文章的评论：


{% if platform_name === "JavaScript" %}
```js
const innerQuery = new AV.Query('Post');
innerQuery.exists('image');

const query = new AV.Query('Comment');
query.matchesQuery('post', innerQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
inner_query = leancloud.Query('Post')
inner_query.exists('images')

query = leancloud.Query('Comment')
query.matches_query('post', inner_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$innerQuery = new Query("Post");
$innerQuery->exists("images");

$query = new Query("Comment");
$query->matchesInQuery("post", $innerQuery);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let innerQuery = LCQuery(className: "Post")
innerQuery.whereKey("image", .existed)

let query = LCQuery(className: "Comment")
query.whereKey("post", .matchedQuery(innerQuery))
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery innerQuery = LCQuery('Post');
innerQuery.whereExists('image');

LCQuery query = LCQuery('Comment');
query.whereMatchesQuery('post', innerQuery);
```
{% endif %}


如需获取某一属性值不是另一查询结果中任一 `{{ baseObjectName }}` 的对象，则使用 `{% if platform_name === "JavaScript" %}doesNotMatchQuery{% endif %}{% if platform_name === "Python" %}does_not_match_query{% endif %}{% if platform_name === "PHP" %}notMatchInQuery{% endif %}{% if platform_name === "Swift" %}.notMatchedQuery{% endif %}{% if platform_name === "Flutter" %}whereDoesNotMatchQuery{% endif %}`。

有时候可能需要获取来自另一个 class 的数据而不想进行额外的查询，此时可以在同一个查询上使用 `{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Python" %}include{% endif %}{% if platform_name === "PHP" %}_include{% endif %}{% if platform_name === "Swift" %}.included{% endif %}{% if platform_name === "Flutter" %}include{% endif %}`。下面的代码查找最新发布的 10 条评论，并包含各自对应的博客文章：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Comment');

// 获取最新发布的
query.descending('createdAt');

// 只获取 10 条
query.limit(10);

// 同时包含博客文章
query.include('post');

query.find().then((comments) => {
  // comments 包含最新发布的 10 条评论，包含各自对应的博客文章
  comments.forEach((comment) => {
    // 该操作无需网络连接
    const post = comment.get('post');
  });
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
query = leancloud.Query('Comment')

# 获取最新发布的
query.add_descending('createdAt')

# 只获取 10 条
query.limit(10)

# 同时包含博客文章
query.include('post')

comment_list = query.find()
for comment in comment_list:
    # 该操作无需网络连接
    post = comment.get('post')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Comment");

// 获取最新发布的
$query->descend("createdAt");

// 只获取 10 条
$query->limit(10);

// 同时包含博客文章
$query->_include("post");

$comments = $query->find();
forEach($comments as $comment) {
    // 该操作无需网络连接
    $post = $comment->get("post");
}
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Comment")

// 获取最新发布的
query.whereKey("createdAt", .descending)

// 只获取 10 条
query.limit = 10

// 同时包含博客文章
query.whereKey("post", .included)

_ = query.find { result in
    switch result {
    case .success(objects: let comments):
        // comments 包含最新发布的 10 条评论，包含各自对应的博客文章
        for comment in comments {
            // 该操作无需网络连接
            let post = comment.get("post") as? LCObject
        }
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Comment');

// 获取最新发布的
query.orderByDescending('createdAt');

// 只获取 10 条
query.limit(10);

// 同时包含博客文章
query.include('post');

// comments 包含最新发布的 10 条评论，包含各自对应的博客文章
List<LCObject> comments = await query.find();
for (LCObject comment in comments) {
// 该操作无需网络连接
  LCObject post = comment['post'];
}
```
{% endif %}


可以用 dot 符号（`.`）来获取多级关系，例如 `post.author`，详见《点号使用指南》的《在查询对象时使用点号》一节。

可以在同一查询上应用多次 `{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Python" %}include{% endif %}{% if platform_name === "PHP" %}_include{% endif %}{% if platform_name === "Swift" %}.included{% endif %}` 以包含多个属性。通过这种方法获取到的对象同样接受 `{% if platform_name === "JavaScript" %}first{% endif %}{% if platform_name === "Python" %}first{% endif %}{% if platform_name === "PHP" %}{% endif %}{% if platform_name === "Swift" %}getFirst{% endif %}`{% if platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Swift" %}、`get`{% endif %} 等 `{{ baseQueryClassName }}` 辅助方法。

通过 `{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Python" %}include{% endif %}{% if platform_name === "PHP" %}_include{% endif %}{% if platform_name === "Swift" %}.included{% endif %}` 进行多级查询的方式不适用于数组属性内部的 `{{ baseObjectName }}`，只能包含到数组本身。

#### 关系查询的注意事项

云端使用的并非关系型数据库，无法做到真正的联表查询，所以实际的处理方式是：先执行内嵌/子查询（和普通查询一样，`limit` 默认为 `100`，最大 `1000`），然后将子查询的结果填入主查询的对应位置，再执行主查询。如果子查询匹配到的记录数量超出 `limit`，且主查询有其他查询条件，那么可能会出现没有结果或结果不全的情况，因为只有 `limit` 数量以内的结果会被填入主查询。

我们建议采用以下方案进行改进：

- 确保子查询的结果在 100 条以下，如果在 100 至 1,000 条之间的话请将子查询的 `limit` 设为 `1000`。
- 将需要查询的字段冗余到主查询所在的表上。
- 进行多次查询，每次在子查询上设置不同的 `skip` 值来遍历所有记录（注意 `skip` 的值较大时可能会引发性能问题，因此不是很推荐）。

### 统计总数量

如果只需知道有多少对象匹配查询条件而无需获取对象本身，可使用 `{% if platform_name === "Go" %}Query.Count(){% endif %}{% if platform_name === "JavaScript" %}count{% endif %}{% if platform_name === "Python" %}count{% endif %}{% if platform_name === "PHP" %}count{% endif %}{% if platform_name === "Swift" %}count{% endif %}` 来代替 `{% if platform_name === "JavaScript" %}find{% endif %}{% if platform_name === "Python" %}find{% endif %}{% if platform_name === "PHP" %}find{% endif %}{% if platform_name === "Swift" %}find{% endif %}{% if platform_name === "Go" %}Query.Find(){% endif %}`。比如说，查询有多少个已完成的 todo：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
query.equalTo('isComplete', true);
query.count().then((count) => {
  console.log(`${count} 个 todo 已完成。`);
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.equal_to('isComplete', True)
count = query.count()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->equalTo("isComplete", true);
$count = $query->count();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("isComplete", .equalTo(true))
let count = query.count()
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Todo');
query.whereEqualTo('isComplete', true);
int count = await query.count();
print('$count 个 todo 已完成');
```
{% endif %}

{% if platform_name === "Go" %}
```go
count, err := client.Class("Todo").NewQuery().EqualTo("isComplete", true).Count()
if err != nil {
  panic(err)
}
fmt.Printf("%d 个 todo 已完成。", count)
```
{% endif %}
### 组合查询

组合查询就是把诸多查询条件用一定逻辑合并到一起（`OR` 或 `AND`）再交给云端去查询。

组合查询不支持在子查询中包含 `GeoPoint` 或其他非过滤性的限制（例如 `near`、`withinGeoBox`、`limit`、`skip`、`ascending`、`descending`、`include`）。

#### OR 查询

OR 操作表示多个查询条件符合其中任意一个即可。 例如，查询优先级大于等于 `3` 或者已经完成了的 todo：


{% if platform_name === "JavaScript" %}
```js
const priorityQuery = new AV.Query('Todo');
priorityQuery.greaterThanOrEqualTo('priority', 3);

const isCompleteQuery = new AV.Query('Todo');
isCompleteQuery.equalTo('isComplete', true);

const query = AV.Query.or(priorityQuery, isCompleteQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')

priority_query = Todo.query
priority_query.greater_than_or_equal_to('priority', 3)

is_complete_query = Todo.query
is_complete_query.equal_to('isComplete', True)

query = leancloud.Query.or_(priority_query, is_complete_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$priorityQuery = new Query("Todo");
$priorityQuery->greaterThanOrEqualTo("priority", 3);

$isCompleteQuery = new Query("Todo");
$isCompleteQuery->equalTo("isComplete", true);

$query = Query::orQuery($priorityQuery, $isCompleteQuery);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let priorityQuery = LCQuery(className: "Todo")
priorityQuery.whereKey("priority", .greaterThanOrEqualTo(3))

let isCompleteQuery = LCQuery(className: "Todo")
isCompleteQuery.whereKey("isComplete", .equalTo(true))

let query = priorityQuery.or(isCompleteQuery)
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> priorityQuery = LCQuery('Todo');
priorityQuery.whereGreaterThanOrEqualTo('priority', 3);

LCQuery<LCObject> isCompleteQuery = LCQuery('Todo');
isCompleteQuery.whereEqualTo('isComplete', true);

LCQuery<LCObject> priorityOneOrTwo = LCQuery.or([priorityQuery, isCompleteQuery]);
List<LCObject> results = await priorityOneOrTwo.find();
```
{% endif %}

{% if platform_name === "Go" %}
```go
priorityQuery := client.Class("Todo").NewQuery().GreaterThanOrEqualTo("priority", 3)
isCompleteQuery := client.Class("Todo").NewQuery().EqualTo("isComplete", true)
query = client.Class("Todo").NewQuery().Or(priorityQuery, isCompleteQuery)
```
{% endif %}
使用 OR 查询时，子查询中不能包含 `GeoPoint` 相关的查询。

#### AND 查询

使用 AND 查询的效果等同于往 `{{ baseQueryClassName }}` 添加多个条件。下面的代码构建的查询会查找创建时间在 `2016-11-13` 和 `2016-12-02` 之间的 todo：


{% if platform_name === "JavaScript" %}
```js
const startDateQuery = new AV.Query('Todo');
startDateQuery.greaterThanOrEqualTo('createdAt', new Date('2016-11-13 00:00:00'));

const endDateQuery = new AV.Query('Todo');
endDateQuery.lessThan('createdAt', new Date('2016-12-03 00:00:00'));

const query = AV.Query.and(startDateQuery, endDateQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

Todo = leancloud.Object.extend('Todo')

start_date_query = Todo.query
start_date_query.greater_than_or_equal_to('createdAt', datetime(2016, 11, 13))

end_date_query = Todo.query
end_date_query.less_than('createdAt', datetime(2016, 12, 3))

query = leancloud.Query.and_(start_date_query, end_date_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$startDate = new \DateTime("2016-11-13");
$startDateQuery = new Query("Todo");
$startDateQuery->greaterThanOrEqualTo("createdAt", $startDate);

$endDate = new \DateTime("2016-12-03");
$endDateQuery = new Query("Todo");
$endDateQuery->lessThan("createdAt", $endDate);

$query = Query::andQuery($startDateQuery, $endDateQuery);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let dateFromString: (String) -> Date? = { string in
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd"
    return dateFormatter.date(from: string)
}

let startDateQuery = LCQuery(className: "Todo")
startDateQuery.whereKey("createdAt", .greaterThanOrEqualTo(dateFromString("2016-11-13")))

let endDateQuery = LCQuery(className: "Todo")
endDateQuery.whereKey("createdAt", .lessThan(dateFromString("2016-12-03")))

let query = startDateQuery.and(endDateQuery)
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> startDateQuery = new LCQuery('Todo');
startDateQuery.whereGreaterThanOrEqualTo('createdAt', DateTime.parse('2016-11-13 00:00:00Z'));

LCQuery<LCObject> endDateQuery = new LCQuery('Todo');
endDateQuery.whereLessThan('createdAt', DateTime.parse('2016-12-03 00:00:00Z'));

LCQuery<LCObject> query = LCQuery.and([startDateQuery, endDateQuery]);
List<LCObject> results = await query.find();
```
{% endif %}

{% if platform_name === "Go" %}
```go
startDateQuery := client.Class("Todo").NewQuery().GreaterThanOrEqualTo("createdAt", time.Parse("2000-01-01 00:00:00Z", "2016-11-13 00:00:00Z"))
endDateQuery := client.Class("Todo").NewQuery().LessThan("createdAt", time.Parse("2000-01-01 00:00:00Z", "2016-12-03 00:00:00Z"))
query := client.Class("Todo").NewQuery().And(startDateQuery, endDateQuery)
```
{% endif %}

单独使用 AND 查询跟使用基础查询相比并没有什么不同，不过当查询条件中包含不止一个 OR 查询时，就必须使用 AND 查询：

{% if platform_name === "Go" %}
```go
createdAtQuery := client.Class("Todo").NewQuery().GreaterThanOrEqualTo("createdAt", time.Parse("2000-01-01", "2018-04-30")).LessThan("createdAt", time.Parse("2000-01-01", "2018-05-01"))

locationQuery := client.Class("Todo").NewQuery().Near("location", leancloud.GeoPoint{30, 150})

priority2Query := client.Class("Todo").NewQuery().EqualTo("priority", 2)

priority3Query := client.Class("Todo").NewQuery().EqualTo("priority", 3)

priorityQuery := client.Class("Todo").NewQuery().Or(priority2Query, priority3Query)

timeLocationQuery := client.Class("Todo").NewQuery().Or(createdAtQuery, locationQuery)

query := client.Class("Todo").NewQuery().And(priorityQuery, timeLocationQuery)
```
{% endif %}

{% if platform_name === "JavaScript" %}
```js
const createdAtQuery = new AV.Query('Todo');
createdAtQuery.greaterThanOrEqualTo('createdAt', new Date('2018-04-30'));
createdAtQuery.lessThan('createdAt', new Date('2018-05-01'));

const locationQuery = new AV.Query('Todo');
locationQuery.doesNotExist('location');

const priority2Query = new AV.Query('Todo');
priority2Query.equalTo('priority', 2);

const priority3Query = new AV.Query('Todo');
priority3Query.equalTo('priority', 3);

const priorityQuery = AV.Query.or(priority2Query, priority3Query);
const timeLocationQuery = AV.Query.or(locationQuery, createdAtQuery);
const query = AV.Query.and(priorityQuery, timeLocationQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

Todo = leancloud.Object.extend('Todo')

created_at_query = Todo.query
created_at_query.greater_than_or_equal_to('createdAt', datetime(2018, 4, 30))
created_at_query.less_than('createdAt', datetime(2018, 5, 1))

location_query = Todo.query
location_query.does_not_exist('location')

priority_2_query = Todo.query
priority_2_query.equal_to('priority', 2)

priority_3_query = Todo.query
priority_3_query.equal_to('priority', 3)

priority_query = leancloud.Query.or_(priority_2_query, priority_3_query)
time_location_query = leancloud.Query.or_(created_at_query, location_query)
query = leancloud.Query.and_(priority_query, time_location_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$startDate = new \DateTime("2018-04-30");
$endDate = new \DateTime("2018-05-01");
$createdAtQuery = new Query("Todo");
$createdAtQuery->greaterThanOrEqualTo("createdAt", $startDate);
$createdAtQuery->lessThan("createdAt", $endDate);

$locationQuery = new Query("Todo");
$locationQuery->notExists("location");

$priority2Query = new Query("Todo");
$priority2Query->equalTo("priority", 2);

$priority3Query = new Query("Todo");
$priority3Query->equalTo("priority", 3);

$priorityQuery = Query::orQuery($priority2Query, $priority3Query);
$timeLocationQuery = Query::orQuery($createdAtQuery, $locationQuery);
$query = Query::andQuery($priorityQuery, $timeLocationQuery);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let dateFromString: (String) -> Date? = { string in
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd"
    return dateFormatter.date(from: string)
}

let createdAtQuery = LCQuery(className: "Todo")
createdAtQuery.whereKey("createdAt", .greaterThanOrEqualTo(dateFromString("2018-04-30")))
createdAtQuery.whereKey("createdAt", .lessThan(dateFromString("2018-05-01")))

let locationQuery = LCQuery(className: "Todo")
locationQuery.whereKey("location", .notExisted)

let priority2Query = LCQuery(className: "Todo")
priority2Query.whereKey("priority", .equalTo(2))

let priority3Query = LCQuery(className: "Todo")
priority3Query.whereKey("priority", .equalTo(3))

let priorityQuery = priority2Query.or(priority3Query)
let timeLocationQuery = locationQuery.or(createdAtQuery)
let query = priorityQuery.and(timeLocationQuery)
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> createdAtQuery = LCQuery('Todo');
createdAtQuery.whereGreaterThanOrEqualTo('createdAt', DateTime.parse('2018-04-30 00:00:00Z'));
createdAtQuery.whereLessThan('createdAt', DateTime.parse('2018-05-01 00:00:00Z'));

LCQuery<LCObject> locationQuery = LCQuery('Todo');
locationQuery.whereDoesNotExist('location');

LCQuery<LCObject> priority2Query = LCQuery('Todo');
priorityQuery.whereEqualTo('priority', 2);

LCQuery<LCObject> priority3Query = LCQuery('Todo');
priorityQuery.whereEqualTo('priority', 3);

LCQuery<LCObject> priorityQuery = LCQuery.or([priority2Query, priority3Query]);
LCQuery<LCObject> timeLocationQuery = LCQuery.or([locationQuery, createdAtQuery]);
LCQuery<LCObject> query = LCQuery.and([priorityQuery, timeLocationQuery]);
```
{% endif %}

{% if platform_name === "Swift" %}
### 缓存查询

缓存一些查询的结果到本地，这可以让你在无网络的时候展现一些数据给用户。

默认情况下 SDK 不会缓存查询结果，可以在 SDK 初始化时配置 `HTTPURLCache` 来开启查询结果缓存：

```swift
do {
    const configuration = LCApplication.Configuration.default
    configuration.HTTPURLCache = URLCache(
        // 内存缓存容量，100 MB
        memoryCapacity: 100 * 1024 * 1024,
        // 磁盘缓存容量，100 MB
        diskCapacity: 100 * 1024 * 1024,
        // `nil` 表示使用系统默认的缓存路径，你也可以自定义路径
        diskPath: nil)
    try LCApplication.default.set(
        id: {{appid}},
        key: {{appkey}},
        // 请将 xxx.example.com 替换为你的应用绑定的自定义 API 域名
        serverURL: "https://xxx.example.com",
        configuration: configuration)
} catch {
    print(error)
}
```

默认情况下，SDK 的查询接口不会查询缓存，可以通过设置接口的 `cachePolicy` 来改变查询行为：

```swift
query.find(cachePolicy: .onlyCache) { (result) in
    switch result {
    case .success(objects: let objects):
        print(objects)
    case .failure(error: let error):
        print(error)
    }
}
```

#### 缓存策略

为了满足多变的需求，SDK 提供了以下几种缓存策略：

策略枚举 | 含义及解释
--- | ---
`onlyNetwork`| **（默认缓存策略）**只从网络加载查询结果。
`onlyCache` | 只从本地缓存加载查询结果。
`networkElseCache` | 先从网络加载查询结果，如果失败，再从本地缓存加载查询结果。

#### 缓存相关的操作

可以参考 Apple 官方文档中[关于 URLCache 的描述](https://developer.apple.com/documentation/foundation/urlcache)。

例如，清除所有本地缓存：

```swift
LCApplication.default.configuration.HTTPURLCache?.removeAllCachedResponses()
```
{% endif %}

### 查询性能优化

影响查询性能的因素很多。特别是当查询结果的数量超过 10 万，查询性能可能会显著下降或出现瓶颈。以下列举一些容易降低性能的查询方式，开发者可以据此进行有针对性的调整和优化，或尽量避免使用。

- 不等于和不包含查询（无法使用索引）
- 通配符在前面的字符串查询（无法使用索引）
- 有条件的 `count`（需要扫描所有数据）
- `skip` 跳过较多的行数（相当于需要先查出被跳过的那些行）
- 无索引的排序（另外除非复合索引同时覆盖了查询和排序，否则只有其中一个能使用索引）
- 无索引的查询（另外除非复合索引同时覆盖了所有条件，否则未覆盖到的条件无法使用索引，如果未覆盖的条件区分度较低将会扫描较多的数据）

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Android / Java" or platform_name === "Swift" or platform_name === ".Net" %}
## LiveQuery

LiveQuery 衍生于 [`{{ baseQueryClassName }}`](#查询)，并为其带来了更强大的功能。它可以让你无需编写复杂的逻辑便可在客户端之间同步数据，这对于有实时数据同步需求的应用来说很有帮助。

设想你正在开发一个多人协作同时编辑一份文档的应用，单纯地使用 `{{ baseQueryClassName }}` 并不是最好的做法，因为它只具备主动拉取的功能，而应用并不知道什么时候该去拉取。

想要解决这个问题，就要用到 LiveQuery 了。借助 LiveQuery，你可以订阅所有需要保持同步的 `{{ baseQueryClassName }}`。订阅成功后，一旦有符合 `{{ baseQueryClassName }}` 的 `{{ baseObjectName }}` 发生变化，云端就会主动、实时地将信息通知到客户端。

LiveQuery 使用 WebSocket 在客户端和云端之间建立连接。WebSocket 的处理会比较复杂，而我们将其封装成了一个简单的 API 供你直接使用，无需关注背后的原理。

### 启用 LiveQuery

进入 **控制台 > 数据存储 > 服务设置**，在 **安全设置** 里面勾选 **启用 LiveQuery**{% if platform_name === "Swift" %}，然后导入云服务Swift SDK：{% endif %}{% if platform_name === "JavaScript" %}，然后将下面的 npm 模块添加到项目中即可：{% endif %}


{% if platform_name === "Swift" %}
```swift
import LeanCloud
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 无需加载 leancloud-storage
const AV = require('leancloud-storage/live-query');
```

或者使用 `script` 标签：

```html
<!-- 无需加载 av-min.js -->
<script src="//code.bdstatic.com/npm/leancloud-storage@{{jssdkversion}}/dist/av-live-query-min.js"></script>
```

可以在 [SDK 安装与初始化](#SDK-安装与初始化) 中找到完整设置方法。
{% endif %}

### Demo

下面是在使用了 LiveQuery 的网页应用和手机应用中分别操作，数据保持同步的效果：

<div style="border:2px solid #ccc; margin-bottom:1em;">
  <video src="https://capacity-files.lcfile.com/1496988080458" controls autoplay muted preload="auto" width="100%" height="100%" >
    HTML5 Video is required for this demo, which your browser doesn't support.
  </video>
</div>

使用我们的「LeanTodo」微信小程序和网页应用，可以实际体验以上视频所演示的效果，步骤如下：

1. 微信扫码，添加小程序「LeanTodo」；

    ![LeanTodo mini program](images/leantodo-weapp-qr.jpg)

2. 进入小程序，点击首页左下角 **设置** > **账户设置**，输入便于记忆的用户名和密码；

3. 使用浏览器访问 <https://leancloud.github.io/leantodo-vue/>，输入刚刚在小程序中更新好的账户信息，点击 **Login**；

4. 随意添加更改数据，查看两端的同步状态。

注意按以上顺序操作。在网页应用中使用 **Signup** 注册的账户无法与小程序创建的账户相关联，所以如果颠倒以上操作顺序，则无法观测到数据同步效果。

[LiveQuery 公开课](http://www.bilibili.com/video/av11291992/) 涵盖了许多开发者关心的问题和解答。

### 构建订阅

首先创建一个普通的 `{{ baseQueryClassName }}` 对象，添加查询条件（如有），然后进行订阅操作：


{% if platform_name === "Swift" %}
```swift
do {
    let query = LCQuery(className: "Todo")
    self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in })
    self.liveQuery.subscribe { (result) in
        switch result {
        case .success:
            break
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
query.subscribe().then((liveQuery) => {
  // 订阅成功
});
```
{% endif %}

LiveQuery 不支持内嵌查询，也不支持返回指定属性。

订阅成功后，就可以接收到和 `{{ baseObjectName }}` 相关的更新了。假如在另一个客户端上创建了一个 `Todo` 对象，对象的 `title` 设为 `更新作品集`，那么下面的代码可以获取到这个新的 `Todo`：


{% if platform_name === "Swift" %}
```swift
do {
    let query = LCQuery(className: "Todo")
    self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
        switch event {
        case .create(object: let object):
            print(object["title"] as Any) // 更新作品集
        default:
            break
        }
    })
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
query.subscribe().then((liveQuery) => {
  liveQuery.on('create', (newTodo) => {
    console.log(newTodo.get('title')); // 更新作品集
  });
});
```
{% endif %}

此时如果有人把 `Todo` 的 `content` 改为 `把我最近画的插画放上去`，那么下面的代码可以获取到本次更新：


{% if platform_name === "Swift" %}
```swift
do {
    let query = LCQuery(className: "Todo")
    self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
        switch event {
        case let .update(object: object, updatedKeys: updatedKeys):
            if let key = updatedKeys.first {
                print(object[key] as Any) // 把我最近画的插画放上去
            }
        default:
            break
        }
    })
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('update', (updatedTodo, updatedKeys) => {
  console.log(updatedTodo.get('content')); // 把我最近画的插画放上去
});
```
{% endif %}

### 事件处理

订阅成功后，可以选择监听如下几种数据变化：

- `create`
- `update`
- `enter`
- `leave`
- `delete`

#### `create` 事件

当有新的满足 `{{ baseQueryClassName }}` 查询条件的 `{{ baseObjectName }}` 被创建时，`create` 事件会被触发。下面的 `object` 就是新建的 `{{ baseObjectName }}`：


{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case .create(object: let object):
        print("对象被创建。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('create', (object) => {
  console.log('对象被创建。');
});
```
{% endif %}

#### `update` 事件

当有满足 `{{ baseQueryClassName }}` 查询条件的 `{{ baseObjectName }}` 被更新时，`update` 事件会被触发。下面的 `object` 就是有更新的 `{{ baseObjectName }}`：


{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case let .update(object: object, updatedKeys: updatedKeys):
        print("对象被更新。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('update', (object, updatedKeys) => {
  console.log('对象被更新。');
});
```
{% endif %}

#### `enter` 事件

当一个已存在的、原本不符合 `{{ baseQueryClassName }}` 查询条件的 `{{ baseObjectName }}` 发生更新，且更新后符合查询条件，`enter` 事件会被触发。下面的 `object` 就是进入 `{{ baseQueryClassName }}` 的 `{{ baseObjectName }}`，其内容为该对象最新的值：


{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case let .enter(object: object, updatedKeys: updatedKeys):
        print("对象进入。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('enter', (object, updatedKeys) => {
  console.log('对象进入。');
});
```
{% endif %}

注意区分 `create` 和 `enter` 的不同行为。如果一个对象已经存在，在更新之前不符合查询条件，而在更新之后符合查询条件，那么 `enter` 事件会被触发。如果一个对象原本不存在，后来被构建了出来，那么 `create` 事件会被触发。

#### `leave` 事件

当一个已存在的、原本符合 `{{ baseQueryClassName }}` 查询条件的 `{{ baseObjectName }}` 发生更新，且更新后不符合查询条件，`leave` 事件会被触发。下面的 `object` 就是离开 `{{ baseQueryClassName }}` 的 `{{ baseObjectName }}`，其内容为该对象最新的值：


{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case let .leave(object: object, updatedKeys: updatedKeys):
        print("对象离开。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('leave', (object, updatedKeys) => {
  console.log('对象离开。');
});
```
{% endif %}

#### `delete` 事件

当一个已存在的、原本符合 `{{ baseQueryClassName }}` 查询条件的 `{{ baseObjectName }}` 被删除，`delete` 事件会被触发。下面的 `object` 就是被删除的 `{{ baseObjectName }}` 的 `objectId`：


{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case .delete(object: let object):
        print("对象被删除。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('delete', (object) => {
  console.log('对象被删除。');
});
```
{% endif %}


### 取消订阅

如果不再需要接收有关 `{{ baseQueryClassName }}` 的更新，可以取消订阅。


{% if platform_name === "Swift" %}
```swift
self.liveQuery.unsubscribe { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.unsubscribe().then(() => {
  // 成功取消订阅
});
```
{% endif %}

### 断开连接

断开连接有几种情况：

1. 网络异常或者网络切换，非预期性断开。
2. 退出应用、关机或者打开飞行模式等，用户在应用外的操作导致断开。

如上几种情况开发者无需做额外的操作，只要切回应用，SDK 会自动重新订阅，数据变更会继续推送到客户端。

而另外一种极端情况——**当用户在移动端使用手机的进程管理工具，杀死了进程或者直接关闭了网页的情况下**，SDK 无法自动重新订阅，此时需要开发者根据实际情况实现重新订阅。

### LiveQuery 的注意事项

因为 LiveQuery 的实时性，很多用户会陷入一个误区，试着用 LiveQuery 来实现一个简单的聊天功能。
我们不建议这样做，因为使用 LiveQuery 构建聊天服务会承担额外的存储成本，产生的费用会增加，后期维护的难度非常大（聊天记录、对话维护之类的代码会很混乱），并且云服务已经提供了即时通讯的服务。
LiveQuery 的核心还是提供一个针对查询的推拉结合的用法，脱离设计初衷容易造成前端的模块混乱。


{% endif %}

## 文件

有时候应用需要存储尺寸较大或结构较为复杂的数据，这类数据不适合用 `{{ baseObjectName }}` 保存，此时文件对象 `{{ fileObjectName }}` 便成为了更好的选择。文件对象最常见的用途是保存图片，不过也可以用来保存文档、视频、音乐等其他二进制数据。

{% if platform_name !== "Go" %}
### 构建文件
{% endif %}
{% if platform_name === "Go" %}
### 上传文件

可以通过传入一个实现了 `io.ReadSeeker` 的类型提供文件内容，并填充 `File` 类型的变量提供文件信息：
```go
// 打开文件
filename := "/tmp/file.txt"
fd, err := os.Open(filename)
if err != nil {
  panic(err)
}
defer fd.Close()

_, name := filepath.Split(filename) // 分割路径以获取文件名
file := &File{ // 构造 File 对象
  Name: name,
  MIME: mime.TypeByExtension(filepath.Ext(name)) // 通过扩展名获取 MIME 类型
}

if err := client.Files.Upload(file, fd); err != nil {
  panic(err)
}
```
{% endif %}


{% if platform_name === "JavaScript" %}
可以通过 base64 编码的字符串构建文件：

```js
const data = { base64: 'TGVhbkNsb3Vk' };
// resume.txt 是文件名
const file = new AV.File('resume.txt', data);
```

还可以通过字节数组构建文件：

```js
const data = [0x4c, 0x65, 0x61, 0x6e, 0x43, 0x6c, 0x6f, 0x75, 0x64];
const file = new AV.File('resume.txt', data);
```

此外，浏览器环境下还可以通过 Blob 构建文件，Node.js 环境下还可以通过 Buffer、Stream 构建文件。

React Native 环境下，可以通过本地路径构建文件：

```js
const data = { blob: { uri: localFileUri } }
const file = new AV.File('resume.txt', data)
```
{% endif %}
{% if platform_name === "Python" %}
可以用 `bytes` 构建文件：

```python
file = leancloud.File("hello.txt", b"hello", mime_type="text/plain")
```
{% endif %}
{% if platform_name === "PHP" %}
可以通过字符串构建文件：

```php
// resume.txt 是文件名
$file = File::createWithData("resume.txt", "LeanCloud");
```
{% endif %}

{% if platform_name === "Swift" %}
可以通过字符串构建文件：

```swift
if let data = "LeanCloud".data(using: .utf8) {
    let file = LCFile(payload: .data(data: data))
}
```
{% endif %}
{% if platform_name === "Flutter" %}
可以通过字符串构建文件：
```dart
LCFile file = LCFile.fromBytes('resume.txt', utf8.encode('LeanCloud'));
```
{% endif %}


除此之外，还可以通过 URL 构建文件：


{% if platform_name === "JavaScript" %}
```js
const file = AV.File.withURL(
  'logo.png',
  'https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png'
);
```
{% endif %}
{% if platform_name === "Python" %}
```python
file = leancloud.File.create_with_url('logo.png', 'https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithUrl("logo.png", "https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
if let url = URL(string: "https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png") {
    let file = LCFile(url: url)
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCFile file = LCFile.fromUrl('logo.png', 'https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png');
```
{% endif %}

{% if platform_name === "Go" %}
```go
file := &File{
	Name: "go-sdk-file-upload.txt",
	MIME: "text/plain",
	URL:  "https://example.com/assets/go-sdk-file-upload.txt",
}

if err := client.Files.UploadFromURL(file); err != nil {
  panic(err)
}
```
{% endif %}
通过 URL 构建文件时，SDK 并不会将原本的文件转储到云端，而是会将文件的物理地址存储为字符串，这样也就不会产生任何文件上传流量。使用其他方式构建的文件会被保存在云端。

{% if platform_name === "JavaScript" or platform_name === "Python" or platform_name === "PHP" or platform_name === "Android / Java" or platform_name === "Swift" or platform_name === "Flutter" or platform_name === ".Net" %}
云端会根据文件扩展名自动检测文件类型。如果需要的话，也可以手动指定 `Content-Type`（一般称为 MIME 类型）：
{% endif %}

{% if platform_name === "JavaScript" %}
```js
const file = new AV.File('resume.txt', data, 'application/json');
```

注意：目前微信小程序环境下不支持指定文件类型。

{% endif %}
{% if platform_name === "Python" %}
```python
file = leancloud.File('resume.txt', b'{"company":"LeanCloud"}', 'application/json')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithData("resume.txt", "{\"company\":\"LeanCloud\"}", "application/json");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
if let data = "{\"company\":\"LeanCloud\"}".data(using: .utf8) {
    let file = LCFile(payload: .data(data: data))
    file.mimeType = "application/json"
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCFile file = LCFile.fromBytes('resume.txt', utf8.encode('LeanCloud'));
file.mimeType = 'application/json';
```
{% endif %}


与前面提到的方式相比，一个更常见的文件构建方式是从本地路径上传。

{% if platform_name === "Go" %}
```go
file, err := client.Files.UploadFromFile("resume.txt")
if err != nil {
	t.Fatal(err)
}
```
{% endif %}

{% if platform_name === "JavaScript" %}
```html
<input type="file" id="avatar-upload" />
```

然后在一个点击事件处理函数中获取这个文件：

```js
const avatarUpload = document.getElementById('avatar-upload');
if (avatarUpload.files.length) {
  const localFile = avatarUpload.files[0];
  const file = new AV.File('avatar.jpg', localFile);
}
```
{% endif %}
{% if platform_name === "Python" %}
```python
with open('/tmp/avatar.jpg', 'rb') as f:
    file = leancloud.File('avatar.jpg', f)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithLocalFile("/tmp/avatar.jpg");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
if let url = Bundle.main.url(forResource: "avatar", withExtension: "jpg") {
    let file = LCFile(payload: .fileURL(fileURL: url))
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCFile file = await LCFile.fromPath('avatar.jpg', './avatar.jpg');
```
{% endif %}


这里上传的文件名字叫做 `avatar.jpg`。需要注意：

- 每个文件会被分配到一个独一无二的 `objectId`，所以在一个应用内是允许多个文件重名的。
- 文件必须有扩展名才能被云端正确地识别出类型。比如说要用 `{{ fileObjectName }}` 保存一个 PNG 格式的图像，那么扩展名应为 `.png`。
- 如果文件没有扩展名，且没有手动指定类型，那么云服务将默认使用 `application/octet-stream`。

{% if platform_name in ["Python", "PHP", "JavaScript"] %}
如果希望指定文件上传后在云端的路径，可以设置文件的 `key` 属性。
例如，上传 robots.txt 文件，限制搜索引擎抓取自定义文件域名下的 URL：
{% endif %}

{% if platform_name == "JavaScript" %}
```js
file.save({ key: 'robots.txt' });
```
{% endif %}
{% if platform_name == "Python" %}
```python
with open('/tmp/robots.txt', 'rb') as f:
    file = leancloud.File('robots.txt', f)
    file.key = 'robots.txt'
```
{% endif %}
{% if platform_name == "PHP" %}
```php
$file = File::createWithData("robots.txt", "User-agent: Twitterbot\nAllow: /imgres");
$file->setKey("robots.txt");
```
{% endif %}

{% if platform_name in ["Python", "PHP"] %}
出于安全性考虑，指定 `key` 属性需要使用 masterKey，否则保存时会报错。
{% endif %}

### 保存文件

将文件保存到云端后，便可获得一个永久指向该文件的 URL：


{% if platform_name === "JavaScript" %}
```js
file.save().then((file) => {
  console.log(`文件保存完成。URL：${file.url}`);
}, (error) => {
  // 保存失败，可能是文件无法被读取，或者上传过程中出现问题
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
file.save()
print(file.url)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file->save();
print $file->getUrl();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = file.save { result in
    switch result {
    case .success:
        if let value = file.url?.value {
            print("文件保存完成。URL: \(value)")
        }
    case .failure(error: let error):
        // 保存失败，可能是文件无法被读取，或者上传过程中出现问题
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
await file.save();
print(file.url);
```
{% endif %}

{% if platform_name === "Go" %}
```go
file, err := client.Files.UploadFromFile("resume.txt")
if err != nil {
    t.Fatal(err)
}

fmt.Println("The URL of file is ", file.URL)
```
{% endif %}
文件上传后，可以在 `_File` class 中找到。已上传的文件无法再被修改。如果需要修改文件，只能重新上传修改过的文件并取得新的 `objectId` 和 URL。

{% if platform_name === "JavaScript" %}
```js
const data = [0x4c, 0x65, 0x61, 0x6e, 0x43, 0x6c, 0x6f, 0x75, 0x64];
const file = new AV.File('resume.txt', data);
file.save({ keepFileName: true }).then((file) => {
  console.log(file.url); // https://your-file-domain/5112b94e0536e995741c/resume.txt
}, (error) => {
  // 保存失败，可能是文件无法被读取，或者上传过程中出现问题
});
```
{% endif %}

已经保存到云端的文件可以关联到 `{{ baseObjectName }}`：


{% if platform_name === "JavaScript" %}
```js
const Todo = AV.Object.extend('Todo');
const todo = new Todo();
todo.set('title', '买蛋糕');
// attachments 是一个 Array 属性
todo.add('attachments', file);
todo.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo()
todo.set('title', '买蛋糕')
# attachments 是一个 Array 属性
todo.add('attachments', file)
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = new LeanObject("Todo");
$todo->set("title", "买蛋糕");
// attachments 是一个 Array 属性
$todo->addIn("attachments", $file);
$todo->save();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
do {
    if let _ = file.objectId?.value {
        let todo = LCObject(className: "Todo")
        try todo.set("attachments", value: file)
        todo.save { (result) in
            switch result {
            case .success:
                break
            case .failure(error: let error):
                print(error)
            }
        }
    }
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCObject todo = LCObject('Todo');
todo['title'] = '买蛋糕';
// attachments 是一个 File 类型
todo.add('attachments', file);
await todo.save();
```
{% endif %}

{% if platform_name === "Go" %}
```go
type Todo struct {
  Title         string `json:"title"`
  Attachment    File   `json:"attachments"`
}

todo := &Todo{
  Title: "买蛋糕",
  Attachment: file,
}

if ref, err := client.Class("Todo").Create(todo); err != nil {
  panic(err)
}
```
{% endif %}
也可以通过构建 `{{ baseQueryClassName }}` 进行[查询](#查询)：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('_File');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query = leancloud.Query('_File')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("_File");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "_File")

```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('_File');
```
{% endif %}

{% if platform_name === "Go" %}
```go
query := client.Class("_File").NewQuery()
```
{% endif %}

需要注意的是，内部文件（上传到文件服务的文件）的 `url` 字段是由云端动态生成的，其中涉及切换自定义域名的相关处理逻辑。
因此，通过 url 字段查询文件仅适用于外部文件（直接保存外部 URL 到 `_File` 表创建的文件），内部文件请改用 key 字段（URL 中的路径）查询。

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Android / Java" or platform_name === "Flutter" or platform_name === ".Net"  %}
注意，如果文件被保存到了 `{{ baseObjectName }}` 的一个数组属性中，那么在查询 `{{ baseObjectName }}` 时如果需要包含文件，则要用到 `{{ baseQueryClassName }}` 的 `{% if platform_name === "JavaScript" %}include{% endif %}` 方法。比如说，在获取所有标题为 `买蛋糕` 的 todo 的同时获取附件中的文件：
{% endif %}


{% if platform_name === "JavaScript" %}
```js
// 获取同一标题且包含附件的 todo
const query = new AV.Query('Todo');
query.equalTo('title', '买蛋糕');
query.exists('attachments');

// 同时获取附件中的文件
query.include('attachments');

query.find().then((todos) => {
  todos.forEach((todo) => {
    // 获取每个 todo 的 attachments 数组
    const attachments = todo.get('attachments');
    attachments.forEach((attachment) => {
      // 每个附件都是一个 AV.File 实例
      console.log(`附件 URL：${attachment.get('url')}`);
    });
  });
});
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
// 获取同一标题且包含附件的 todo
LCQuery<LCObject> query = LCQuery('Todo');
query.whereEqualTo('title', '买蛋糕');
query.whereExists('attachments');

// 同时获取附件中的文件
query.include('attachments');
List<LCObject> todos = await query.find();
for (LCObject todo in todos) {
// 获取每个 todo 的 attachments 数组
  List<LCObject> attachments = todo['attachments'];
}
```
{% endif %}


{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Android / Java" or platform_name === "Swift" or platform_name === "Flutter" or platform_name === ".Net" %}
### 上传进度监听

上传过程中可以实时向用户展示进度：
{% endif %}


{% if platform_name === "JavaScript" %}
```js
file.save({
  onprogress: (progress) => {
    console.log(progress);
    // {
    //   loaded:  1024,
    //   total:   2048,
    //   percent: 50
    // }
  }
}).then((file) => {
  // 保存后的操作
});
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = file.save(progress: { (progress) in
    print(progress)
}) { (result) in
    switch result {
    case .success:
        // 保存后的操作
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
await file.save(onProgress: (int count, int total) {
print('$count/$total');
if (count == total) {
  print('done');
}
});
```
{% endif %}


### 文件元数据

上传文件时，可以用 `metaData` 添加额外的属性。文件一旦保存，`metaData` 便不可再修改。


{% if platform_name === "JavaScript" %}
```js
// 设置元数据
file.metaData('author', 'LeanCloud');
file.save().then((file) => {
  // 获取全部元数据
  const metadata = file.metaData();
  // 获取 author 属性
  const author = file.metaData('author');
  // 获取文件名
  const fileName = file.get('name');
  // 获取大小（不适用于通过 base64 编码的字符串或者 URL 保存的文件）
  const size = file.size();
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 设置元数据
file.metadata['author'] = 'LeanCloud'
file.save()

# 获取全部元数据
metadata = file.metadata
# 获取 author 属性
author = metadata['author']
# 获取文件名
file_name = file.name
# 获取大小（不适用于通过 base64 编码的字符串或者 URL 保存的文件）
size = file.size
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 设置元数据
$file->setMeta("author", "LeanCloud");
$file->save();

// 获取全部元数据
$metadata = $file->getMeta();
// 获取 author 属性
$author = $file->getMeta("author");
// 获取文件名
$fileName = $file->getName();
// 获取大小（不适用于通过 base64 编码的字符串或者 URL 保存的文件）
$size = $file->getSize();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
// 设置元数据
file.metaData["author"] = "LeanCloud"
_ = file.save { result in
    switch result {
    case .success:
        // 获取 author 属性
        String? author = file.metaData["author"]
        // 获取文件名
        String? fileName = file.name
        // 获取大小（不适用于通过 base64 编码的字符串或者 URL 保存的文件）
        UInt64? size = file.metaData["size"]
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
file.addMetaData('size', 1024);
file.addMetaData('width', 128);
file.addMetaData('height', 256);
file.mimeType = 'image/jpg';
await file.save();
```
{% endif %}

{% if platform_name === "Go" %}
```go
// 打开文件
filename := "/tmp/file.txt"
fd, err := os.Open(filename)
if err != nil {
  panic(err)
}
defer fd.Close()

_, name := filepath.Split(filename) // 分割路径以获取文件名
file := &File{ // 构造 File 对象
  Name: name,
  MIME: mime.TypeByExtension(filepath.Ext(name)) // 通过扩展名获取 MIME 类型
  Metadata: map[string]interface{ // 设置 Metadata
    "size": 1024,
    "width": 128,
    "height": 256,
  }
}

if err := client.Files.Upload(file, fd); err != nil {
  panic(err)
}

```
{% endif %}


{% if platform_name === "Objective-C" or platform_name === "Swift" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "PHP" or platform_name === "Android / Java" %}
### 图像缩略图

成功保存图像后，除了可以获取指向该文件的 URL 外，还可以获取图像的缩略图 URL，并且可以指定缩略图的宽度和高度：


{% if platform_name === "Swift" %}
```swift
// 基于原图大小，按指定百分比缩放到 25%
let scaledURL = file.thumbnailURL(.scale(0.25))
// 按指定宽高值强行缩略，获得宽度为 100 像素，高度 200 像素的缩略图
let sizedURL = file.thumbnailURL(.size(width: 100, height: 200))
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 获得宽度为 100 像素，高度 200 像素的缩略图
const url = file.thumbnailURL(100, 200);
```
{% endif %}
{% if platform_name === "Python" %}
```python
avatar = leancloud.File.create_without_data('5732df1c1ea4930060ba4642')
avatar.fetch()

thumbnail_url = avatar.get_thumbnail_url(width=100, height=100)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithUrl("test.jpg", "文件-url");
// 获得宽度为 100 像素，高度 200 像素的缩略图
$file->getThumbUrl(100, 200);
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
 // 获得宽度为 100 像素，高度为 200 像素的缩略图 url
 String url = file.getThumbnailUrl(100, 200);
```
{% endif %}


图片最大不超过 **20 MB** 才可以获取缩略图。

国际版不支持图片缩略图。
{% endif %}



### 删除文件

下面的代码从云端删除一个文件：


{% if platform_name === "JavaScript" %}
```js
const file = AV.File.createWithoutData('552e0a27e4b0643b709e891e');
file.destroy();
```
{% endif %}
{% if platform_name === "Python" %}
```python
file = leancloud.File.create_without_data('552e0a27e4b0643b709e891e')
file.destroy()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::fetch("552e0a27e4b0643b709e891e");
$file->destroy();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let file = LCObject(className: "_File", objectId: "552e0a27e4b0643b709e891e")
file.delete()
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCFile file = LCObject.createWithoutData('_File', '552e0a27e4b0643b709e891e');
await file.delete();
```
{% endif %}

{% if platform_name === "Go" %}
```go
if err := client.File("552e0a27e4b0643b709e891e").Destroy(); err != nil {
  panic(err)
}
```
{% endif %}
默认情况下，文件的删除权限是关闭的，需要进入 **云服务控制台 > 数据存储 > 结构化数据 > `_File`**，选择 **权限** > **`delete`** 来开启。

{% if platform_name === "JavaScript" %}
## Promise

每一个在 JavaScript SDK 中的异步方法都会返回一个 `Promise`，可以用于处理该异步方法的完成与异常。下面的示例代码在查询到一个 `AV.Object` 后对其进行更新：

```js
const query = new AV.Query('Todo');
query.equalTo('priority', 1);
// find 方法是一个异步方法，会返回一个 Promise，之后可以使用 then 方法
query.find().then((todos) => {
  // 返回符合条件的对象组成的数组
  const todo = todos[0];
  todo.set('notes', '今天需要完成。');
  // save 方法也是一个异步方法，会返回一个 Promise，所以在此处，你可以直接 return 出去，后续操作就可以支持链式 Promise 调用
  return todo.save();
}).then(() => {
  // 这里是 save 方法返回的 Promise
  console.log('成功更新 todo。');
}).catch((error) => {
  // catch 方法写在 Promise 链式的最后，可以捕捉到全部 error
  console.error(error);
});
```

### `then` 方法

每一个 `Promise` 都有一个叫 `then` 的方法，这个方法接受一对 callback。第一个 callback 在 `Promise` 被解决（`resolved`，也就是正常运行）的时候调用，第二个会在 `Promise` 被拒绝（`rejected`，也就是遇到错误）的时候调用：

```js
todo.save().then((todo) => {
  console.log('成功更新 todo。');
}, (error) => {
  console.error(error);
});
```

其中第二个参数是可选的。

你还可以使用 `catch` 方法，将逻辑写成：

```js
todo.save().then((todo) => {
  console.log('成功更新 todo。');
}).catch((error) => {
  console.error(error);
});
```

### 将 `Promise` 组织在一起

Promise 比较神奇，可以代替多层嵌套方式来解决发送异步请求代码的调用顺序问题。如果一个 `Promise` 的回调会返回一个 `Promise`，那么第二个 `then` 里的 callback 在第一个 `then` 的 callback 没有解决前是不会解决的，也就是所谓 **Promise Chain**。

```js
// 将内容按章节顺序添加到页面上
const chapterIds = [
  '584e1c408e450a006c676162', // 第一章
  '584e1c43128fe10058b01cf5', // 第二章
  '581aff915bbb500059ca8d0b'  // 第三章
];

new AV.Query('Chapter').get(chapterIds[0]).then((chapterOne) => {
  // 向页面添加内容
  addHtmlToPage(chapterOne.get('content'));
  // 返回新的 Promise
  return new AV.Query('Chapter').get(chapterIds[1]);
}).then((chapterTwo) => {
  addHtmlToPage(chapterTwo.get('content'));
  return new AV.Query('Chapter').get(chapterIds[2]);
}).then((chapterThree) => {
  addHtmlToPage(chapterThree.get('content'));
  // 完成
});
```

### 错误处理

如果任意一个在链中的 `Promise` 抛出一个异常的话，所有接下来可能成功的 callback 都会被跳过直到遇到一个处理错误的 callback。

通常来说，在正常情况的回调函数链的末尾，加一个错误处理的回调函数，是一种很常见的做法。

利用 `catch` 方法可以将上述代码改写为：

```js
new AV.Query('Chapter').get(chapterIds[0]).then((chapterOne) => {
  addHtmlToPage(chapterOne.get('content'));
  // 强制失败
  throw new Error('出错啦');
  return new AV.Query('Chapter').get(chapterIds[1]);
}).then((chapterTwo) => {
  // 这里的代码将被忽略
  addHtmlToPage(chapterTwo.get('content'));
  return new AV.Query('Chapter').get(chapterIds[2]);
}).then((chapterThree) => {
  // 这里的代码将被忽略
  addHtmlToPage(chapterThree.get('content'));
}).catch((error) => {
  // 这个错误处理函数将被调用，错误信息是 '出错啦'
  console.error(error.message);
});
```

### `async` 和 `await`

`async` 和 `await` 能让你以更接近同步代码的方式使用 Promise：

```js
async function example() {
  try {
    const query = new AV.Query('Todo');
    query.equalTo('priority', 1);
    const todos = await query.find();
    const todo = todos[0];
    todo.set('notes', '今天需要完成。');
    return await todo.save();
  } catch (error) {
    console.error(error);
  }
}
```

如果你想更深入地了解和学习 Promise，包括如何对并行的异步操作进行控制，我们推荐阅读 [JavaScript Promise迷你书（中文版）](http://liubin.github.io/promises-book/)这本书。
{% endif %}

## GeoPoint

云服务允许你通过将 `{{ geoPointObjectName }}` 关联到 `{{ baseObjectName }}` 的方式存储折射真实世界地理位置的经纬坐标，这样做可以让你查询包含一个点附近的坐标的对象。常见的使用场景有「查找附近的用户」和「查找附近的地点」。

要构建一个包含地理位置的对象，首先要构建一个地理位置。下面的代码构建了一个 `{{geoPointObjectName}}` 并将其纬度（`latitude`）设为 `39.9`，经度（`longitude`）设为 `116.4`：


{% if platform_name === "JavaScript" %}
```js
const point = new AV.GeoPoint(39.9, 116.4);

// 其他构建 AV.GeoPoint 的方式
const point = new AV.GeoPoint([39.9, 116.4]);
const point = new AV.GeoPoint({ latitude: 39.9, longitude: 116.4 });
```
{% endif %}
{% if platform_name === "Python" %}
```python
point = leancloud.GeoPoint(39.9, 116.4)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$point = new GeoPoint(39.9, 116.4);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let point = LCGeoPoint(latitude: 39.9, longitude: 116.4)
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCGeoPoint point = LCGeoPoint(39.9, 116.4);
```
{% endif %}

{% if platform_name === "Go" %}
```go
point := leancloud.GeoPoint{
  Latitude: 39.9,
  Longitude: 116.4,
}
```
{% endif %}

现在可以将这个地理位置存储为一个对象的属性：


{% if platform_name === "JavaScript" %}
```js
todo.set('location', point);
```
{% endif %}
{% if platform_name === "Python" %}
```python
todo.set('location', point)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo->set("location", $point);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
try todo.set("location", value: point)
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
todo['location'] = point;
```
{% endif %}

{% if platform_name === "Go" %} 
```go
if err := client.Class("Todo").Set("location", point); err != nil {
  panic(err)
}
```
{% endif %}
### 地理位置查询

给定一些含有地理位置的对象，可以从中找出离某一点最近的几个，或者处于某一范围内的几个。要执行这样的查询，可以向普通的 `{{ baseQueryClassName }}` 添加 `{% if platform_name === "Go" %}Near{% endif %}{% if platform_name === "JavaScript" %}near{% endif %}{% if platform_name === "Python" %}near{% endif %}{% if platform_name === "PHP" %}near{% endif %}{% if platform_name === "Swift" %}.locatedNear{% endif %}` 条件。下面的代码查找 `location` 属性值离某一点最近的 `Todo` 对象：


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
const point = new AV.GeoPoint(39.9, 116.4);
query.near('location', point);

// 限制为 10 条结果
query.limit(10);
query.find().then((todos) => {
  // todos 是包含满足条件的 Todo 对象的数组
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
query = leancloud.Query('Todo')
point = leancloud.GeoPoint(39.9, 116.4)
query.near('location', point)

# 限制为 10 条结果
query.limit(10)
todo_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$point = new GeoPoint(39.9, 116.4);
$query->near("location", $point);

// 限制为 10 条结果
$query->limit(10);
$todos = $query->find();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
let point = LCGeoPoint(latitude: 39.9, longitude: 116.4)
query.whereKey("location", .locatedNear(point))

// 限制为 10 条结果
query.limit = 10
_ = query.find { result in
    switch result {
    case .success(objects: let todos):
        // todos 是包含满足条件的 Todo 对象的数组
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Todo');
LCGeoPoint point = LCGeoPoint(39.9, 116.4);
query.whereNear('location', point);

// 限制为 10 条结果
query.limit(10);
// todos 是包含满足条件的 Todo 对象的数组
List<LCObject> todos = await query.find();
```
{% endif %}

{% if platform_name === "Go" %}
```go
point := &leancloud.GeoPoint{
  Latitude: 39.9,
  Longitude: 116.4,
}

todos := make([]Todo, 0)

if err := client.Class("Todo").NewQuery().Near("location", point).Limit(10).Find(&todos); err != nil {
  panic(err)
}
```
像 `Order` 这样额外的排序条件会获得比默认的距离排序更高的优先级。
{% endif %}
{% if platform_name !== "Go" %}
像 `{% if platform_name === "JavaScript" %}ascending{% endif %}{% if platform_name === "Python" %}ascending{% endif %}{% if platform_name === "PHP" %}ascend{% endif %}{% if platform_name === "Swift" %}.ascending{% endif %}{% if platform_name === "Flutter" %}orderByAscending{% endif %}` 和 `{% if platform_name === "JavaScript" %}descending{% endif %}{% if platform_name === "Python" %}descending{% endif %}{% if platform_name === "PHP" %}descend{% endif %}{% if platform_name === "Swift" %}.descending{% endif %}{% if platform_name === "Flutter" %}orderByDescending{% endif %}` 这样额外的排序条件会获得比默认的距离排序更高的优先级。
{% endif %}

若要限制结果和给定地点之间的距离，可以参考 API 文档中的 {% if platform_name === "Go" %}`WithinKilometers`、`WithinMiles` 和 `WithinRadians`{% endif %}{% if platform_name === "JavaScript" %}`withinKilometers`、`withinMiles` 和 `withinRadians`{% endif %}{% if platform_name === "Python" %}`within_kilometers`、`within_miles` 和 `within_radians`{% endif %}{% if platform_name === "PHP" %}`withinKilometers`、`withinMiles` 和 `withinRadians`{% endif %}{% if platform_name === "Swift" %} `kilometersTo`、`milesTo` 和 `radiansTo`{% endif %} 参数。

若要查询在某一矩形范围内的对象，可以用 {% if platform_name === "Go" %}`WithinGeoBox`{% endif %}{% if platform_name === "JavaScript" %}`withinGeoBox`{% endif %}{% if platform_name === "Python" %}`within_geo_box`{% endif %}{% if platform_name === "PHP" %}`withinBox`{% endif %}{% if platform_name === "Swift" %}`.locatedWithin`{% endif %}{% if platform_name === "Flutter" %}`whereWithinGeoBox`{% endif %}：

![withinGeoBox](images/geopoint-withingeobox.svg)


{% if platform_name === "JavaScript" %}
```js
const query = new AV.Query('Todo');
const southwest = new AV.GeoPoint(30, 115);
const northeast = new AV.GeoPoint(40, 118);
query.withinGeoBox('location', southwest, northeast);
```
{% endif %}
{% if platform_name === "Python" %}
```python
query = leancloud.Query('Todo')
southwest = leancloud.GeoPoint(30, 115)
northeast = leancloud.GeoPoint(40, 118)
query.within_geo_box('location', southwest, northeast)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$southwest = new GeoPoint(30, 115);
$northeast = new GeoPoint(40, 118);
$query->withinBox("location", $southwest, $northeast);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
let southwest = LCGeoPoint(latitude: 30, longitude: 115)
let northeast = LCGeoPoint(latitude: 40, longitude: 118)
query.whereKey("location", .locatedWithin(southwest: southwest, northeast: northeast))
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCObject> query = LCQuery('Todo');
LCGeoPoint southwest = LCGeoPoint(30, 115);
LCGeoPoint northeast = LCGeoPoint(40, 118);
query.whereWithinGeoBox('location', southwest, northeast);
```
{% endif %}

{% if platform_name === "Go" %}
```go
southwest := leancloud.GeoPoint{30, 115}
northeast := leancloud.GeoPoint{40, 118}
query := client.Class("Todo").WithinBox("location", southwest, northeast)
```
{% endif %}
### GeoPoint 的注意事项

GeoPoint 的经纬度的类型是数字，且经度需在 -180.0 到 180.0 之间，纬度需在 -90.0 到 90.0 之间。
另外，每个对象最多只能有一个类型为 GeoPoint 的属性。

## 用户

用户系统几乎是每款应用都要加入的功能，我们为此专门提供了一个 `{{ userObjectName }}` 类来方便应用使用各项用户管理的功能。

`{{ userObjectName }}` 是 `{{ baseObjectName }}` 的子类，这意味着任何 `{{ baseObjectName }}` 提供的方法也适用于 `{{ userObjectName }}`，唯一的区别就是 `{{ userObjectName }}` 提供一些额外的用户管理相关的功能。每个应用都有一个专门的 `_User` class 用于存放所有的 `{{ userObjectName }}`。

### 用户的属性

`{{ userObjectName }}` 相比一个普通的 `{{ baseObjectName }}` 多出了以下属性：

- `username`：用户的用户名。
- `password`：用户的密码。
- `email`：用户的电子邮箱。
- `emailVerified`：用户的电子邮箱是否已验证。
- `mobilePhoneNumber`：用户的手机号。
- `mobilePhoneVerified`用户的手机号是否已验证。

在接下来对用户功能的介绍中我们会逐一了解到这些属性。

### 注册

用户第一次打开应用的时候，可以让用户注册一个账户。下面的代码展示了一个典型的使用用户名和密码注册的流程：


{% if platform_name === "JavaScript" %}
```js
// 创建实例
const user = new AV.User();

// 等同于 user.set('username', 'Tom')
user.setUsername('Tom');
user.setPassword('cat!@#123');

// 可选
user.setEmail('tom@leancloud.rocks');
user.setMobilePhoneNumber('+8618200008888');

// 设置其他属性的方法跟 AV.Object 一样
user.set('gender', 'secret');

user.signUp().then((user) => {
  // 注册成功
  console.log(`注册成功。objectId：${user.id}`);
}, (error) => {
  // 注册失败（通常是因为用户名已被使用）
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 创建实例
user = leancloud.User()

# 等同于 user.set('username', 'Tom')
user.set_username('Tom')
user.set_password('cat!@#123')

# 可选
user.set_email('tom@leancloud.rocks')
user.set_mobile_phone_number('+8618200008888')

# 设置其他属性的方法跟 leancloud.Object 一样
user.set('gender', 'secret')

user.sign_up()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 创建实例
$user = new User();

// 等同于 $user->set("username", "Tom")
$user->setUsername("Tom");
$user->setPassword("cat!@#123");

// 可选
$user->setEmail("tom@leancloud.rocks");
$user->setMobilePhoneNumber("+8618200008888");

// 设置其他属性的方法跟 LeanObject 一样
$user->set("gender", "secret");

$user->signUp();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
do {
    // 创建实例
    let user = LCUser()

    // 等同于 user.set("username", value: "Tom")
    user.username = LCString("Tom")
    user.password = LCString("cat!@#123")

    // 可选
    user.email = LCString("tom@leancloud.rocks")
    user.mobilePhoneNumber = LCString("+8618200008888")

    // 设置其他属性的方法跟 LCObject 一样
    try user.set("gender", value: "secret")

    _ = user.signUp { (result) in
        switch result {
        case .success:
            break
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
// 创建实例
LCUser user = LCUser();

// 等同于 user['username'] = 'Tom';
user.username = 'Tom';
user.password = 'cat!@#123';

// 可选
user.email = 'tom@leancloud.rocks';
user.mobile = '+8618200008888';

// 设置其他属性的方法跟 LCObject 一样
user['gender'] = 'secret';
await user.signUp();
```
{% endif %}

{% if platform_name === "Go" %}
```go
// 注册用户
user, err := client.Users.SignUp("Tom", "cat!@#123")
if err != nil {
  panic(err)
}

// 设置其它属性
if err := client.Users.ID(user.ID).Set("email", "tom@leancloud.rocks", leancloud.UseUser(user)); err != nil {
  panic(err)
}
```
{% endif %}
{% if platform_name !== "Go" %}
新建 `{{ userObjectName }}` 的操作应使用 `{% if platform_name === "JavaScript" %}signUp{% endif %}{% if platform_name === "Python" %}sign_up{% endif %}{% if platform_name === "PHP" %}signUp{% endif %}{% if platform_name === "Swift" %}signUp{% endif %}{% if platform_name === "Flutter" %}signUp{% endif %}` 而不是 `{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Python" %}save{% endif %}{% if platform_name === "PHP" %}save{% endif %}{% if platform_name === "Swift" %}save{% endif %}{% if platform_name === "Flutter" %}save{% endif %}`，但以后的更新操作就可以用 `{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Python" %}save{% endif %}{% if platform_name === "PHP" %}save{% endif %}{% if platform_name === "Swift" %}save{% endif %}{% if platform_name === "Flutter" %}save{% endif %}` 了。
{% endif %}
如果收到 `202` 错误码，意味着 `_User` 表里已经存在使用同一 `username` 的账号，此时应提示用户换一个用户名。除此之外，每个用户的 `email` 和 `mobilePhoneNumber` 也需要保持唯一性，否则会收到 `203` 或 `214` 错误。
可以考虑在注册时把用户的 `username` 设为与 `email` 相同，这样用户可以直接 [用邮箱重置密码](#重置密码)。

采用「用户名 + 密码」注册时需要注意：密码是以明文方式通过 HTTPS 加密传输给云端，云端会以密文存储密码（云端对密码的长度、复杂度不作限制），并且我们的加密算法是无法通过所谓「彩虹表撞库」获取的，这一点请开发者放心。换言之，用户的密码只可能用户本人知道，开发者不论是通过控制台还是 API 都是无法获取。另外我们需要强调 **在客户端，应用切勿再次对密码加密，这会导致 [重置密码](#重置密码) 等功能失效**。

#### 手机号注册

对于移动应用来说，允许用户以手机号注册是个很常见的需求。实现该功能大致分两步，第一步是让用户提供手机号，点击「获取验证码」按钮后，该号码会收到一个六位数的验证码：


{% if platform_name === "JavaScript" %}
```js
AV.Cloud.requestSmsCode('+8618200008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.cloud.request_sms_code('+8618200008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
SMS::requestSmsCode("+8618200008888");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
//templateName 是短信模版名称，signatureName 是短信签名名称。可以在控制台 > 短信 > 设置中查看。
_ = LCSMSClient.requestShortMessage(mobilePhoneNumber: "+8618200008888", templateName: "template_name", signatureName: "sign_name") { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
await LCSMSClient.requestSMSCode('+8618200008888');
```
{% endif %}

{% if platform_name === "Go" %}
```go
if err := client.Users.RequestMobilePhoneVerify("+8618200008888"); err != nil {
  panic(err)
}
```
{% endif %}
用户填入验证码后，用下面的方法完成注册：


{% if platform_name === "JavaScript" %}
```js
AV.User.signUpOrlogInWithMobilePhone('+8618200008888', '123456').then((user) => {
  // 注册成功
  console.log(`注册成功。objectId：${user.id}`);
}, (error) => {
  // 验证码不正确
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
user = leancloud.User.signup_or_login_with_mobile_phone('+8618200008888', '123456')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::signUpOrLoginByMobilePhone("+8618200008888", "123456");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.signUpOrLogIn(mobilePhoneNumber: "+8618200008888", verificationCode: "123456", completion: { (result) in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
})
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
 await LCUser.signUpOrLoginByMobilePhone('+8618200008888', '123456');
```
{% endif %}

{% if platform_name === "Go" %}
```go
user, err := client.Users.SignUpByMobilePhone("+8618200008888", "123456")
if err != nil {
  panic(err)
}
```
{% endif %}
`username` 将与 `mobilePhoneNumber` 相同，`password` 会由云端随机生成。
如果希望让用户指定密码，可以在客户端让用户填写手机号和密码，然后按照上一小节使用用户名和密码注册的流程，将用户填写的手机号作为 `username` 和 `mobilePhoneNumber` 的值同时提交。
同时根据业务需求，在**云服务控制台 > 内建账户 > 设置**勾选**未验证手机号码的用户，禁止登录**、**已验证手机号码的用户，允许以短信验证码登录**。

#### 手机号格式

`{{ userObjectName }}` 接受的手机号以 `+` 和国家代码开头，后面紧跟着剩余的部分。手机号中不应含有任何划线、空格等非数字字符。例如，`+19490008888` 是一个合法的美国或加拿大手机号（`1` 是国家代码），`+8618200008888` 是一个合法的中国手机号（`86` 是国家代码）。

请参阅官网的价格页面以了解支持的国家和地区。

### 登录

下面的代码用用户名和密码登录一个账户：


{% if platform_name === "JavaScript" %}
```js
AV.User.logIn('Tom', 'cat!@#123').then((user) => {
  // 登录成功
}, (error) => {
  // 登录失败（可能是密码错误）
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
user = leancloud.User()
user.login(username='Tom', password='cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logIn("Tom", "cat!@#123");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(username: "Tom", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
try {
  // 登录成功
  LCUser user = await LCUser.login('Tom', 'cat!@#123');
} on LCException catch (e) {
  // 登录失败（可能是密码错误）
  print('${e.code} : ${e.message}');
}
```
{% endif %}

{% if platform_name === "Go" %}
```go
user, err := client.Users.LogIn("Tom", "cat!@#123")
if err != nil {
  panic(err)
}
```
{% endif %}
#### 邮箱登录

下面的代码用邮箱和密码登录一个账户：


{% if platform_name === "JavaScript" %}
```js
AV.User.loginWithEmail('tom@leancloud.rocks', 'cat!@#123').then((user) => {
  // 登录成功
}, (error) => {
  // 登录失败（可能是密码错误）
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
user = leancloud.User()
user.login(email='tom@leancloud.rocks', password='cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logInWithEmail("tom@leancloud.rocks", "cat!@#123");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(email: "tom@leancloud.rocks", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
try {
  // 登录成功
  LCUser user = await LCUser.loginByEmail('tom@leancloud.rocks', 'cat!@#123');
} on LCException catch (e) {
  // 登录失败（可能是密码错误）
  print('${e.code} : ${e.message}');
}
```
{% endif %}

{% if platform_name === "Go" %}
```go
user, err := client.LoginByEmail("tom@leancloud.rocks", "cat!@#123")
if err != nil {
  panic(err)
}

fmt.Println(user)
```
{% endif %}
#### 手机号登录

如果应用允许用户以手机号注册，那么也可以让用户以手机号配合密码或短信验证码登录。下面的代码用手机号和密码登录一个账户：


{% if platform_name === "JavaScript" %}
```js
AV.User.logInWithMobilePhone('+8618200008888', 'cat!@#123').then((user) => {
  // 登录成功
}, (error) => {
  // 登录失败（可能是密码错误）
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
user = leancloud.User.login_with_mobile_phone('+8618200008888', 'cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logInWithMobilePhoneNumber("+8618200008888", "cat!@#123");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(mobilePhoneNumber: "+8618200008888", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
try {
  // 登录成功
  LCUser user = await LCUser.loginByMobilePhoneNumber('+8618200008888', 'cat!@#123');
} on LCException catch (e) {
  // 登录失败（可能是密码错误）
  print('${e.code} : ${e.message}');
}
```
{% endif %}


默认情况下，云服务允许所有关联了手机号的用户直接以手机号登录，无论手机号是否 [通过验证](#验证手机号)。为了让应用更加安全，你可以选择只允许验证过手机号的用户通过手机号登录。可以在 **控制台 > 内建账户 > 设置** 里面开启该功能。

除此之外，还可以让用户通过短信验证码登录，适用于用户忘记密码且不愿重置密码的情况。和 [通过手机号注册](#手机号注册) 的步骤类似，首先让用户填写与账户关联的手机号码，然后在用户点击「获取验证码」后调用下面的方法：


{% if platform_name === "JavaScript" %}
```js
AV.User.requestLoginSmsCode('+8618200008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_login_sms_code('+8618200008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
SMS::requestSmsCode("+8618200008888");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestLoginVerificationCode(mobilePhoneNumber: "+8618200008888") { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
await LCUser.requestLoginSMSCode('+8618200008888');
```
{% endif %}

{% if platform_name === "Go" %}
```go
if err := client.Users.RequestLoginSMSCode("+8618200008888"); err != nil {
    panic(err)
}
```
{% endif %}
用户填写收到的验证码后，用下面的方法完成登录：


{% if platform_name === "JavaScript" %}
```js
AV.User.logInWithMobilePhoneSmsCode('+8618200008888', '123456').then((user) => {
  // 登录成功
}, (error) => {
  // 验证码不正确
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
user = leancloud.User.signup_or_login_with_mobile_phone('+8618200008888', '123456')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::signUpOrLoginByMobilePhone("+8618200008888", "123456");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(mobilePhoneNumber: "+8618200008888", verificationCode: "123456") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
try {
  // 登录成功
  await LCUser.signUpOrLoginByMobilePhone('+8618200008888', '123456');
} on LCException catch (e) {
  // 登录失败（可能是密码错误）
  print('${e.code} : ${e.message}');
}
```
{% endif %}

{% if platform_name === "Go" %}
```go
user, err := client.Users.LogInByMobilePhoneNumber("+8618200008888", "123456")
if err != nil {
    panic(err)
}
```
{% endif %}
#### 测试手机号和固定验证码

在开发过程中，可能会因测试目的而需要频繁地用手机号注册登录，然而运营商的发送频率限制往往会导致测试过程耗费较多的时间。

为了解决这个问题，可以在 **控制台 > 短信 > 设置** 里面设置一个测试手机号，而云端会为该号码生成一个固定验证码。以后进行登录操作时，只要使用的是这个号码，云端就会直接放行，无需经过运营商网络。

测试手机号还可用于将 iOS 应用提交到 App Store 进行审核的场景，因为审核人员可能因没有有效的手机号码而无法登录应用来进行评估审核。如果不提供一个测试手机号，应用有可能被拒绝。

可参阅 [短信 SMS 服务使用指南](sms-guide.html) 来了解更多有关短信发送和接收的限制。

#### 单设备登录

某些场景下需要确保用户的账户在同一时间只在一台设备上登录，也就是说当用户在一台设备上登录后，其他设备上的会话全部失效。可以按照以下方案来实现：

1. 新建一个专门用于记录用户登录信息和当前设备信息的 class。
2. 每当用户在新设备上登录时，将该 class 中该用户对应的设备更新为该设备。
3. 在另一台设备上打开客户端时，检查该设备是否与云端保存的一致。若不一致，则将用户 [登出](#当前用户)。

#### 账户锁定

输入错误的密码或验证码会导致用户登录失败。如果在 15 分钟内，同一个用户登录失败的次数大于 6 次，该用户账户即被云端暂时锁定，此时云端会返回错误码 `{ "code": 1, "error": "You have exceeded the maximum number of login attempts, please try again later, or consider resetting your password." }`，开发者可在客户端进行必要提示。

锁定将在最后一次错误登录的 15 分钟之后由云端自动解除，开发者无法通过 SDK 或 REST API 进行干预。在锁定期间，即使用户输入了正确的验证信息也不允许登录。这个限制在 SDK 和云引擎中都有效。

### 验证邮箱

可以通过要求用户在登录或使用特定功能之前验证邮箱的方式防止恶意注册。默认情况下，当用户注册或变更邮箱后，`emailVerified` 会被设为 `false`。在应用的 **云服务控制台 > 内建账户 > 设置** 中，可以开启 **启用邮箱验证功能** 选项，这样当用户注册或变更邮箱时，会收到一封含有验证链接的邮件。在同一设置页面还可找到阻止未验证邮箱的用户登录的选项。

如果用户忘记点击链接并且在未来某一时刻需要进行验证，可以用下面的代码发送一封新的邮件：


{% if platform_name === "JavaScript" %}
```js
AV.User.requestEmailVerify('tom@leancloud.rocks');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_email_verify('tom@leancloud.rocks')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestEmailVerify("tom@leancloud.rocks");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestVerificationMail(email: "tom@leancloud.rocks") { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
await LCUser.requestEmailVerify('tom@leancloud.rocks');
```
{% endif %}

{% if platform_name === "Go" %}
```go
if err := client.Users.RequestEmailVerify("tom@leancloud.rocks"); err != nil {
    panic(err)
}
```
{% endif %}
用户点击邮件内的链接后，`emailVerified` 会变为 `true`。如果用户的 `email` 属性为空，则该属性永远不会为 `true`。

### 验证手机号

和 [验证邮箱](#验证邮箱) 类似，应用还可以要求用户在登录或使用特定功能之前验证手机号。默认情况下，当用户注册或变更手机号后，`mobilePhoneVerified` 会被设为 `false`。
在应用的「控制台 > 内建账户 > 设置」中，可以开启阻止未验证手机号的用户登录的选项。

可以用下面的代码发送一条新的验证码：（如果相应用户的 `mobilePhoneVerified` 已经为 `true`，那么验证短信不会发送）


{% if platform_name === "JavaScript" %}
```js
AV.User.requestMobilePhoneVerify('+8618200008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_mobile_phone_verify('+8618200008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestMobilePhoneVerify("+8618200008888");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestVerificationCode(mobilePhoneNumber: "+8618200008888") { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
await LCUser.requestMobilePhoneVerify('+8618200008888');
```
{% endif %}

{% if platform_name === "Go" %}
```go
if err := client.Users.RequestMobilePhoneVerify("+8618200008888"); err != nil {
    panic(err)
}
```
{% endif %}
用户填写验证码后，调用下面的方法来完成验证。`mobilePhoneVerified` 将变为 `true`：


{% if platform_name === "JavaScript" %}
```js
AV.User.verifyMobilePhone('123456').then(() => {
  // mobilePhoneVerified 将变为 true
}, (error) => {
  // 验证码不正确
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.verify_mobile_phone_number('123456')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::verifyMobilePhone("123456");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.verifyMobilePhoneNumber(mobilePhoneNumber: "+8618200008888", verificationCode: "123456") { result in
    switch result {
    case .success:
        // mobilePhoneVerified 将变为 true
        break
    case .failure(error: let error):
        // 验证码不正确
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
await LCUser.verifyMobilePhone('+8618200008888','123456');
```
{% endif %}


#### 绑定、修改手机号之前先验证

除了在用户绑定、修改手机号**之后**进行验证，云服务也支持在用户绑定或修改手机号**之前**先通过短信验证。
也就是说，绑定手机号或修改手机号时先请求发送验证码（用户需处于登录状态），再凭短信验证码完成绑定或修改操作。

{% if platform_name === "JavaScript" %}
```js
AV.User.requestChangePhoneNumber('+8618200008888');

AV.User.changePhoneNumber('+8618200008888', '123456').then(() => {
    // 更新本地数据
    const currentUser = AV.User.current();
    currentUser.setMobilePhoneNumber('+8618200008888');
}, (error) => {
    // 验证码不正确
});
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestVerificationCode(forUpdatingMobilePhoneNumber: "+8618200008888") { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}

_ = LCUser.verifyVerificationCode("123456", toUpdateMobilePhoneNumber:"+8618200008888") { result in
    switch result {
    case .success:
        // mobilePhoneNumber 变为 +8618200008888
        // mobilePhoneVerified 变为 true
        break
    case .failure(error: let error):
        // 验证码不正确
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
await LCUser.requestSMSCodeForUpdatingPhoneNumber('+8618200008888');

await LCUser.verifyCodeForUpdatingPhoneNumber('+8618200008888', '123456');
// 更新本地数据
LCUser currentUser = await LCUser.getCurrent();
user.mobile = '+8618200008888';
```
{% endif %}

{% if platform_name === "Python" %}
```python
User.request_change_phone_number("+8618200008888")

User.change_phone_number("123456", "+8618200008888")
# 更新本地数据
current_user = leancloud.User.get_current()
current_user.set_mobile_phone_number("+8618200008888")
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestChangePhoneNumber("+8618200008888");

User::changePhoneNumber("123456", "+8618200008888");
// 更新本地数据
$currentUser = User::getCurrentUser();
$user->setMobilePhoneNumber("+8618200008888");
```
{% endif %}
{% if platform_name === "Go" %}
```go
if err := client.Users.requestChangePhoneNumber("+8618200008888"); err != nil {
  panic(err)
}

if err := client.Users.ChangePhoneNumber("123456", "+8618200008888"); err != nil {
  panic(err)
}
```
{% endif %}
### 当前用户

用户登录后，SDK 会自动将会话信息存储到客户端，这样用户在下次打开客户端时无需再次登录。下面的代码检查是否有已经登录的用户：


{% if platform_name === "Swift" %}
```swift
if let user = LCApplication.default.currentUser {
    // 跳到首页
} else {
    // 显示注册或登录页面
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
const currentUser = AV.User.current();
if (currentUser) {
  // 跳到首页
} else {
  // 显示注册或登录页面
}
```
{% endif %}
{% if platform_name === "Python" %}
```python
current_user = leancloud.User.get_current()
if current_user is not None:
    # 跳到首页
    pass
else:
    # 显示注册或登录页面
    pass
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$currentUser = User::getCurrentUser();
if ($currentUser != null) {
    // 跳到首页
} else {
    // 显示注册或登录页面
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
LCUser currentUser = await LCUser.getCurrent();
if (currentUser != null) {
  // 跳到首页
} else {
  // 显示注册或登录页面
}
```
{% endif %}

{% if platform_name === "Go" %}
```go
// TODO
```
{% endif %}
会话信息会长期有效，直到用户主动登出：


{% if platform_name === "Swift" %}
```swift
LCUser.logOut()

// currentUser 变为 nil
let currentUser = LCApplication.default.currentUser
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.logOut();

// currentUser 变为 null
const currentUser = AV.User.current();
```
{% endif %}
{% if platform_name === "Python" %}
```python
user.logout()

current_user = leancloud.User.get_current()  # None
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logOut();

// currentUser 变为 null
$currentUser = User::getCurrentUser();
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
await LCUser.logout();

// currentUser 变为 null
LCUser currentUser = await LCUser.getCurrent();
```
{% endif %}


### 设置当前用户

用户登录后，云端会返回一个 **session token** 给客户端，它会由 SDK 缓存起来并用于日后同一 `{{ userObjectName }}` 的鉴权请求。session token 会被包含在每个客户端发起的 HTTP 请求的 header 里面，这样云端就知道是哪个 `{{ userObjectName }}` 发起的请求了。

以下是一些应用可能需要用到 session token 的场景：

- 应用根据以前缓存的 session token 登录（可以用 `{% if platform_name === "JavaScript" %}AV.User.current().getSessionToken(){% endif %}{% if platform_name === "Python" %}leancloud.User.get_current().get_session_token(){% endif %}{% if platform_name === "PHP" %}User::getCurrentSessionToken(){% endif %}{% if platform_name === "Swift" %}LCApplication.default.currentUser?.sessionToken?.value{% endif %}` 获取到当前用户的 session token，在服务端等受信任的环境下，可以通过 Master Key 读取任意用户的 `sessionToken` 字段以获取 session token）。
- 应用内的某个 WebView 需要知道当前登录的用户。
- 在服务端登录后，返回 session token 给客户端，客户端根据返回的 session token 登录。

下面的代码使用 session token 登录一个用户（云端会验证 session token 是否有效）：


{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(sessionToken: "anmlwi96s381m6ca7o7266pzf") { (result) in
    switch result {
    case .success(object: let user):
        // 登录成功
        print(user)
    case .failure(error: let error):
        // session token 无效
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.become('anmlwi96s381m6ca7o7266pzf').then((user) => {
  // 登录成功
}, (error) => {
  // session token 无效
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
user = leancloud.User.become('anmlwi96s381m6ca7o7266pzf')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::become("anmlwi96s381m6ca7o7266pzf");
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
await LCUser.becomeWithSessionToken('anmlwi96s381m6ca7o7266pzf');
```
{% endif %}

{% if platform_name === "Go" %}
```go
user, err := client.Users.Become("anmlwi96s381m6ca7o7266pzf")
if err != nil {
    panic(err)
}
```
{% endif %}
请避免在外部浏览器使用 URL 来传递 session token，以防范信息泄露风险。

如果在 **控制台 > 内建账户 > 设置** 中勾选了 **密码修改后，强制客户端重新登录**，那么当一个用户修改密码后，该用户的 session token 会被重置。此时需要让用户重新登录，否则会遇到 [`403 (Forbidden)`](error_code.html#_403) 错误。

下面的代码检查 session token 是否有效：


{% if platform_name === "Swift" %}
```swift
if let sessionToken = LCApplication.default.currentUser?.sessionToken?.value {
    _ = LCUser.logIn(sessionToken: sessionToken) { (result) in
        if result.isSuccess {
            // session token 有效
        } else {
            // session token 无效
        }
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
const currentUser = AV.User.current();
currentUser.isAuthenticated().then((authenticated) => {
  if (authenticated) {
    // session token 有效
  } else {
    // session token 无效
  }
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
authenticated = leancloud.User.get_current().is_authenticated()
if authenticated:
    # session token 有效
    pass
else:
    # session token 无效
    pass
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$authenticated = User::isAuthenticated();
if ($authenticated) {
    // session token 有效
} else {
    // session token 无效
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
LCUser currentUser = await LCUser.getCurrent();
bool isAuthenticated = await currentUser.isAuthenticated();
if (isAuthenticated) {
  // session token 有效
} else {
  // session token 无效
}
```
{% endif %}

{% if platform_name === "Go" %}
```go
// 暂不支持
```
{% endif %}
### 重置密码

我们都知道，应用一旦加入账户密码系统，那么肯定会有用户忘记密码的情况发生。对于这种情况，我们为用户提供了多种重置密码的方法。

邮箱重置密码的流程如下：

1. 用户输入注册的电子邮箱，请求重置密码；
2. 云端向该邮箱发送一封包含重置密码的特殊链接的电子邮件；
3. 用户点击重置密码链接后，一个特殊的页面会打开，让他们输入新密码；
4. 用户的密码已被重置为新输入的密码。

首先让用户填写注册账户时使用的邮箱，然后调用下面的方法：


{% if platform_name === "JavaScript" %}
```js
AV.User.requestPasswordReset('tom@leancloud.rocks');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_password_reset('tom@leancloud.rocks')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestPasswordReset("tom@leancloud.rocks");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestPasswordReset(email: "tom@leancloud.rocks") { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
await LCUser.requestPasswordReset('tom@leancloud.rocks');
```
{% endif %}

{% if platform_name === "Go" %}
```go
if err := client.Users.RequestPasswordReset("tom@leancloud.rocks"); err != nil {
    panic(err)
}
```
{% endif %}
上面的代码会查询 `_User` 表中是否有对象的 `email` 属性与前面提供的邮箱匹配。如果有的话，则向该邮箱发送一封密码重置邮件。之前提到过，应用可以让 `username` 与 `email` 保持一致，也可以单独收集用户的邮箱并将其存为 `email`。

密码重置邮件的内容可在应用的 **云服务控制台 > 内建账户 > 邮件模版** 中自定义。更多关于自定义邮件模板和验证链接的内容，请参考《自定义邮件验证和重设密码页面》。

除此之外，还可以用手机号重置密码：

1. 用户输入注册的手机号，请求重置密码；
2.云端向该号码发送一条包含验证码的短信；
3. 用户输入验证码和新密码。

下面的代码向用户发送含有验证码的短信：


{% if platform_name === "JavaScript" %}
```js
AV.User.requestPasswordResetBySmsCode('+8618200008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_password_reset_by_sms_code('+8618200008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestPasswordResetBySmsCode("+8618200008888");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestPasswordReset(mobilePhoneNumber: "+8618200008888") { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
await LCUser.requestPasswordRestBySmsCode('+8618200008888');
```
{% endif %}

{% if platform_name === "Go" %}
```go
if err := client.Users.RequestPasswordResetBySmsCode("+8618200008888"); err != nil {
    panic(err)
}
```
{% endif %}
上面的代码会查询 `_User` 表中是否有对象的 `mobilePhoneNumber` 属性与前面提供的手机号匹配。如果有的话，则向该号码发送验证码短信。

可以在 **云服务控制台 > 内建账户 > 设置** 中设置只有在 `mobilePhoneVerified` 为 `true` 的情况下才能用手机号重置密码。

用户输入验证码和新密码后，用下面的代码完成密码重置：


{% if platform_name === "JavaScript" %}
```js
AV.User.resetPasswordBySmsCode('123456', 'cat!@#123').then(() => {
  // 密码重置成功
}, (error) => {
  // 验证码不正确
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.reset_password_by_sms_code('123456', 'cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::resetPasswordBySmsCode("123456", "cat!@#123");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.resetPassword(mobilePhoneNumber: "+8618200008888", verificationCode: "123456", newPassword: "cat!@#123") { result in
    switch result {
    case .success:
        // 密码重置成功
        break
    case .failure(error: let error):
        // 验证码不正确
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
await LCUser.resetPasswordBySmsCode('+8618200008888', '123456', 'cat!@#123');
```
{% endif %}

{% if platform_name === "Go" %}
```go
if err := client.Users.ResetPasswordBySmsCode("+8618200008888", "123456", "cat!@#123"); err != nil {
    panic(err)
}
```
{% endif %}

### 用户的查询

可以直接构建一个针对 `_User` 的 `{{ baseQueryClassName }}` 来查询用户：


{% if platform_name === "JavaScript" %}
```js
const userQuery = new AV.Query('_User');
```
{% endif %}
{% if platform_name === "Python" %}
```python
user_query = leancloud.Query('_leancloud.User')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$userQuery = new Query("_User");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let userQuery = LCQuery(className: "_User")
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCQuery<LCUser> userQuery = LCUser.getQuery();
```
{% endif %}

{% if platform_name === "Go" %}
```go
userQuery := client.Users.NewUserQuery()
```
{% endif %}

为了安全起见，**新创建的应用的 `_User` 表默认关闭了 `find` 权限**，这样每位用户登录后只能查询到自己在 `_User` 表中的数据，无法查询其他用户的数据。如果需要让其查询其他用户的数据，建议单独创建一张表来保存这类数据，并开放这张表的 `find` 查询权限。除此之外，还可以在云引擎里封装用户查询相关的方法。

可以参见 [用户对象的安全](#用户对象的安全) 来了解 `_User` 表的一些限制，还可以阅读《数据和安全》来了解更多 class 级权限设置的方法。

### 关联用户对象

关联 `{{ userObjectName }}` 的方法和 `{{ baseObjectName }}` 是一样的。下面的代码为一名作者保存了一本书，然后获取所有该作者写的书：


{% if platform_name === "JavaScript" %}
```js
const Book = AV.Object.extend('Book');
const book = new Book();
const author = AV.User.current();
book.set('title', '我的第五本书');
book.set('author', author);
book.save().then((book) => {
  // 获取所有该作者写的书
  const query = new AV.Query('Book');
  query.equalTo('author', author);
  query.find().then((books) => {
    // books 是包含同一作者所有 Book 对象的数组
  });
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Book = leancloud.Object.extend('Book')
book = Book()
author = leancloud.User.get_current()
book.set('title', '我的第五本书')
book.set('author', author)
book.save()

# 获取所有该作者写的书
query = Book.query
query.equal_to('author', author)
book_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$book = new LeanObject("Book");
$author = User::getCurrentUser();
$book->set("title", "我的第五本书");
$book->set("author", $author);
$book->save();

// 获取所有该作者写的书
$query = new Query("Book");
$query->equalTo("author", $author);
$books = $query->find();
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
do {
    guard let author = LCApplication.default.currentUser else {
        return
    }
    let book = LCObject(className: "Book")
    try book.set("title", value: "我的第五本书")
    try book.set("author", value: author)
    _ = book.save { result in
        switch result {
        case .success:
            // 获取所有该作者写的书
            let query = LCQuery(className: "Book")
            query.whereKey("author", .equalTo(author))
            _ = query.find { result in
                switch result {
                case .success(objects: let books):
                    // books 是包含同一作者所有 Book 对象的数组
                    break
                case .failure(error: let error):
                    print(error)
                }
            }
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
LCObject book = LCObject('Book');
LCUser author = await LCUser.getCurrent();
book['title'] = '我的第五本书';
book['author'] = author;
await book.save();

LCQuery<LCObject> query = LCQuery('Book');
query.whereEqualTo('author', author);
// books 是包含同一作者所有 Book 对象的数组
List<LCObject> books = await query.find();
```
{% endif %}

{% if platform_name === "Go" %}
```go
// TODO
```
{% endif %}
### 用户对象的安全

`{{ userObjectName }}` 类自带安全保障，只有通过 `{%if platform_name === "Go" %}LogIn{% endif %}{% if platform_name === "JavaScript" %}logIn{% endif %}{% if platform_name === "Python" %}login{% endif %}{% if platform_name === "PHP" %}logIn{% endif %}{% if platform_name === "Swift" %}logIn{% endif %}` 或者 `{% if platform_name === "JavaScript" %}signUp{% endif %}{% if platform_name === "Python" %}sign_up{% endif %}{% if platform_name === "PHP" %}signUp{% endif %}{% if platform_name === "Swift" %}signUp{% endif %}{%if platform_name === "Go" %}SignUp{% endif %}` 这种经过鉴权的方法获取到的 `{{ userObjectName }}` 才能进行保存或删除相关的操作，保证每个用户只能修改自己的数据。

这样设计是因为 `{{ userObjectName }}` 中存储的大多数数据都比较敏感，包括手机号、社交网络账号等等。为了用户的隐私安全，即使是应用的开发者也应避免直接接触这些数据。

下面的代码展现了这种安全措施：


{% if platform_name === "JavaScript" %}
```js
const user = AV.User.logIn('Tom', 'cat!@#123').then((user) => {
  // 试图修改用户名
  user.set('username', 'Jerry');
  // 密码已被加密，这样做会获取到空字符串
  const password = user.get('password');
  // 保存更改
  user.save().then((user) => {
    // 可以执行，因为用户已鉴权

    // 绕过鉴权直接获取用户
    const query = new AV.Query('_User');
    query.get(user.objectId).then((unauthenticatedUser) => {
      unauthenticatedUser.set('username', 'Toodle');
      unauthenticatedUser.save().then((unauthenticatedUser) => { }, (error) => {
        // 会出错，因为用户未鉴权
      });
    });
  });
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.login('Tom', 'cat!@#123')
current_user = leancloud.User.get_current()

# 试图修改用户名
current_user.set('username', 'Jerry')
# 密码已被加密，这样做会获取到空字符串
password = current_user.get('password')
# 可以执行，因为用户已鉴权
current_user.save()

# 绕过鉴权直接获取用户
query = leancloud.Query('_User')
unauthenticated_user = query.get(current_user.id)
unauthenticated_user.set('username', 'Toodle')
# 会出错，因为用户未鉴权
unauthenticated_user.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logIn("Tom", "cat!@#123");
$currentUser = User::getCurrentUser();

// 试图修改用户名
$currentUser->set("username", "Jerry");
// 密码已被加密，这样做会获取到空字符串
$password = $currentUser->get("password");
// 可以执行，因为用户已鉴权
$currentUser->save();

// 绕过鉴权直接获取用户
$query = new Query("_User");
$unauthenticatedUser = $query->get($currentUser->getObjectId())
$unauthenticatedUser->set("username", "Toodle");
// 会出错，因为用户未鉴权
$unauthenticatedUser->save()
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(username: "Tom", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        // 试图修改用户名
        try! user.set("username", "Jerry")
        // 密码已被加密，这样做会获取到空字符串
        let password = user.get("password")
        // 可以执行，因为用户已鉴权
        user.save()

        // 绕过鉴权直接获取用户
        let query = LCQuery(className: "_User")
        _ = query.get(user.objectId) { result in
            switch result {
                case .success(object: let unauthenticatedUser):
                    try! unauthenticatedUser.set("username", "Toodle")
                    _ = unauthenticatedUser.save { result in
                        switch result {
                            .success:
                                // 无法执行，因为用户未鉴权
                            .failure:
                                // 操作失败
                        }
                    }
                case .failure(error: let error):
                    print(error)
            }
        }
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Flutter" %}
```dart
try {
  LCUser user = await LCUser.login('Tom', 'cat!@#123');
  // 试图修改用户名
  user['username'] = 'Jerry';
  // 密码已被加密，这样做会获取到空字符串
  String password = user['password'];
  // 可以执行，因为用户已鉴权
  await user.save();

  // 绕过鉴权直接获取用户
  LCQuery<LCUser> userQuery = LCQuery('_User');
  LCUser unauthenticatedUser = await userQuery.get(user.objectId);
  unauthenticatedUser['username'] = 'Toodle';

  // 会出错，因为用户未鉴权
  unauthenticatedUser.save();
} on LCException catch (e) {
  print('${e.code} : ${e.message}');
}
```
{% endif %}

{% if platform_name === "Go" %}
```go
user, err := client.Users.LogIn("Tom", "cat!@#123")
if err != nil {
    panic(err)
}

// 试图修改用户名，未鉴权将失败
if err := client.User(user).Set("username", "Jerry"); err != nil {
    panic(err)
}

// 密码已被加密，这样做会获取到空字符串
password := user.String("password")

// 可以执行，因为用户已鉴权
if err := client.User(user).Set("username", "Jerry", leancloud.UseUser(user)); err != nil {
    panic(err)
}

// 绕过鉴权直接获取用户
unauthenticatedUser := User{}
if err := client.Users.NewUserQuery().EqualTo("objectId", user.ID).First(&unauthenticatedUser); err != nil {
    panic(err)
}

// 会出错，因为用户未鉴权
if err := client.User(unauthenticatedUser).Set("username", "Toodle"); err != nil {
    panic(err)
}
```
{% endif %}
通过 `{% if platform_name === "JavaScript" %}AV.User.current(){% endif %}{% if platform_name === "Python" %}leancloud.User.get_current(){% endif %}{% if platform_name === "PHP" %}User::getCurrentUser(){% endif %}{% if platform_name === "Swift" %}LCApplication.default.currentUser{% endif %}{% if platform_name === "Flutter" %}LCUser.getCurrent(){% endif %}` 获取的 `{{ userObjectName }}` 总是经过鉴权的。

要查看一个 `{{ userObjectName }}` 是否经过鉴权，可以调用 `{% if platform_name === "JavaScript" %}isAuthenticated{% endif %}{% if platform_name === "Python" %}is_authenticated{% endif %}{% if platform_name === "PHP" %}isAuthenticated{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}` 方法。通过经过鉴权的方法获取到的 `{{ userObjectName }}` 无需进行该检查。

注意，用户的密码只能在注册的时候进行设置，日后如需修改，只能通过 [重置密码](#重置密码) 的方式进行。密码不会被缓存在本地。如果尝试直接获取已登录用户的密码，会得到 `null`。

### 其他对象的安全

对于给定的一个对象，可以指定哪些用户有权限读取或修改它。为实现该功能，每个对象都有一个由 `{% if platform_name === "JavaScript" %}AV.ACL{% endif %}{% if platform_name === "Python" %}leancloud.ACL{% endif %}{% if platform_name === "PHP" %}ACL{% endif %}{% if platform_name === "Swift" %}LCACL{% endif %}` 对象组成的访问控制表。请参阅《ACL 权限管理开发指南》。

### 第三方账户登录

云服务支持应用层直接使用第三方社交平台（例如微信、微博、QQ 等）的账户信息来创建自己的账户体系并完成登录，也允许将既有账户与第三方账户绑定起来，这样终端用户后续可以直接用第三方账户信息来便捷登录。

例如以下的代码展示了终端用户使用微信登录的处理流程：

{% if platform_name === "JavaScript" %}
```js
const thirdPartyData = {
  // 必须
  openid:        'OPENID',
  access_token:  'ACCESS_TOKEN',
  expires_in:    7200,

  // 可选
  refresh_token: 'REFRESH_TOKEN',
  scope:         'SCOPE'
};
AV.User.loginWithAuthData(thirdPartyData, 'weixin').then((user) => {
  // 登录成功
}, (error) => {
  // 登录失败
});
```
{% endif %}

{% if platform_name === "Python" %}
{# TODO #}
{% endif %}

{% if platform_name === "PHP" %}
{# TODO #}
{% endif %}

{% if platform_name === "Swift" %}
```swift
let thirdPartyData: [String: Any] = [
    // 必须
    "openid":        "OPENID",
    "access_token":  "ACCESS_TOKEN",
    "expires_in":    7200,

    // 可选
    "refresh_token": "REFRESH_TOKEN",
    "scope":         "SCOPE"
]
let user = LCUser()
user.logIn(authData: thirdPartyData, platform: .weixin) { (result) in
    switch result {
    case .success:
        assert(user.objectId != nil)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
var thirdPartyData = {
  // 必须
  'openid':        'OPENID',
  'access_token':  'ACCESS_TOKEN',
  'expires_in':    7200,

  // 可选
  'refresh_token': 'REFRESH_TOKEN',
  'scope':         'SCOPE'
};
LCUser currentUser = await LCUser.loginWithAuthData(thirdPartyData, 'weixin');
```
{% endif %}

{% if platform_name === "Go" %}
```go
// TODO
```
{% endif %}
`{{ userObjectName }}#loginWithAuthData` 系列方法需要两个参数来唯一确定一个账户：

- 第三方平台的名字，就是前例中的 `weixin`，该名字由应用层自己决定。
- 第三方平台的授权信息，就是前例中的 `thirdPartyData`（一般包括 `uid`、`token`、`expires` 等信息，与具体的第三方平台有关）。

云端会使用第三方平台的鉴权信息来查询是否已经存在与之关联的账户。如果存在的话，则返回 `200 OK` 状态码，同时附上用户的信息（包括 [`sessionToken`](#设置当前用户)）。如果第三方平台的信息没有和任何账户关联，客户端会收到 `201 Created` 状态码，意味着新账户被创建，同时附上用户的 `objectId`、`createdAt`、`sessionToken` 和一个自动生成的 `username`，例如：

```json
{
  "username":     "k9mjnl7zq9mjbc7expspsxlls",
  "objectId":     "5b029266fb4ffe005d6c7c2e",
  "createdAt":    "2018-05-21T09:33:26.406Z",
  "updatedAt":    "2018-05-21T09:33:26.575Z",
  "sessionToken": "…",
  // authData 通常不会返回，继续阅读以了解其中原因
  "authData": {
    "weixin": {
      "openid":        "OPENID",
      "access_token":  "ACCESS_TOKEN",
      "expires_in":    7200,
      "refresh_token": "REFRESH_TOKEN",
      "scope":         "SCOPE"
    }
  }
  // …
}
```

这时候我们会看到 `_User` 表中出现了一条新的账户记录，账户中有一个名为 `authData` 的列，保存了第三方平台的授权信息。出于安全考虑，`authData` 不会被返回给客户端，除非它属于当前用户。

开发者需要自己完成第三方平台的鉴权流程（一般通过 OAuth 1.0 或 2.0），以获取鉴权信息，继而到云端来登录。

{% if platform_name in ["Swift", "Objective-C", "Flutter"] %}

#### Sign in with Apple
如果你需要开发 [Sign in with Apple](https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api)，云服务可以帮你校验 `identityToken`，并获取 Apple 的 `access_token`。Apple Sign In 的 `authData` 结构如下：

```json
{
  "lc_apple": {
    "uid": "从 Apple 获取到的 User Identifier",
    "identity_token": "从苹果获取到的 identityToken",
    "code": "从苹果获取到的 Authorization Code"
  }
}
```
`authData` 中的 key 的作用：

* **`lc_apple`**：只有 platform 为 `lc_apple` 时，云服务才会执行 `identity_token` 和 `code` 的逻辑。
* **`uid`**：必填。云服务通过 `uid` 判断是否存在用户。
* **`identity_token`**：可选。`authData` 中有 `identity_token` 时云端会自动校验 `identity_token` 的有效性。开发者需要在云服务控制台「存储」-「用户」-「设置」-「第三方集成」中填写 Apple 的相关信息。
* **`code`**：可选。`authData` 中有 `code` 时云端会自动用该 `code` 向 Apple 换取 `access_token` 和 `refresh_token`。开发者需要在云服务控制台「存储」-「用户」-「设置」-「第三方集成」中填写 Apple 的相关信息。

##### 获取 Client ID

Client ID 用于校验 `identity_token` 及获取 `access_token`，指的是 Apple 应用的 identifier，也就是 AppID 或 serviceID。对于原生应用来说，指的是 Xcode 中的 Bundle Identifier，例如 `com.mytest.app`。详情请参考 [Apple 的文档](https://developer.apple.com/documentation/sign_in_with_apple/generate_and_validate_tokens)。

##### 获取 Private Key 及 Private Key ID

Private Key 用于获取 `access_token`。登录 Apple 开发者平台，在左侧的 「Certificates, Identifiers & Profiles」 中选择 「Keys」，添加一个用于 Apple Sign In 的 Private Key，下载 XXXXX.p8 文件，同时在下载 Key 的页面获得 Private Key ID。详情请参考[ Apple 的文档](https://help.apple.com/developer-account/#/dev77c875b7e)。

将 Key ID 填写到控制台，将下载下来的 Private Key 文件上传到控制台。控制台只能上传 Private Key 文件，无法查看及下载其内容。

##### 获取 Team ID

Team ID 用于获取 `access_token`。登录 Apple 开发者平台，在右上角或 Membership 页面即可看到自己所属开发团队的 Team ID。注意选择 Bundle ID 对应的 Team。

##### 使用 Apple Sign In 登录云服务

在控制台填写完成所有信息后，使用以下代码登录

{% endif %}


{% if platform_name === "Swift" %}
```swift
let appleData: [String: Any] = [
    // 必须
    "uid":             "USER IDENTIFIER",
    // 可选
    "identity_token":  "IDENTITY TOKEN",
    "code":            "AUTHORIZATION CODE"
]
let user = LCUser()
user.logIn(authData: appleData, platform: .apple) { (result) in
    switch result {
    case .success:
        assert(user.objectId != nil)
    case .failure(error: let error):
        print(error)
    }
}

```

{% endif %}

{% if platform_name === "Flutter" %}
```dart
var appleData = {
    // 必须
    "uid":             "USER IDENTIFIER",
    // 可选
    "identity_token":  "IDENTITY TOKEN",
    "code":            "AUTHORIZATION CODE"
};
LCUser currentUser = await LCUser.loginWithAuthData(appleData, 'lc_apple');
```
{% endif %}

#### 鉴权数据的保存

`_User` class 中的 `authData` 是一个以平台名为键名，鉴权信息为键值的 JSON 对象。

一个关联了微信账户的用户应该会有下列对象作为 `authData`：

```json
{
  "weixin": {
    "openid":        "…",
    "access_token":  "…",
    "expires_in":    7200,
    "refresh_token": "…",
    "scope":         "…"
  }
}
```

而一个关联了微博账户的用户，则会有如下的 `authData`：

```json
{
    "weibo": {
      "refresh_token": "2.0xxx",
      "uid": "271XFEFEW273",
      "expires_in": 115057,
      "access_token": "2.00xxx",
    }
}
```

我们允许一个账户绑定多个第三方平台的鉴权数据，这样如果某个用户同时关联了微信和微博账户，则其 `authData` 可能会是这样的：

```json
{
  "weixin": {
    "openid":        "…",
    "access_token":  "…",
    "expires_in":    7200,
    "refresh_token": "…",
    "scope":         "…"
  },
  "weibo": {
    "refresh_token": "2.0xxx",
    "uid": "271XFEFEW273",
    "expires_in": 115057,
    "access_token": "2.00xxx",
  }
}
```

理解 `authData` 的数据结构至关重要。一个终端用户通过如下的鉴权信息来登录的时候，

```json
"weixin": {
  "openid":        "OPENID",
  "access_token":  "ACCESS_TOKEN",
  "expires_in":    7200,
  "refresh_token": "REFRESH_TOKEN",
  "scope":         "SCOPE"
}
```

云端首先会查找账户系统（_User 表），看看是否存在 authData.weixin.openid = “OPENID” 的账户，如果存在，则返回现有账户，如果不存在那么就创建一个新账户，同时将上面的鉴权信息写入新账户的 `authData` 属性中，并将新账户的数据当成结果返回。

云端会自动为 `_User` class 中每个用户的 `authData.<PLATFORM>.<uid>` 创建唯一索引，从而避免重复数据。
`<uid>` 在微信等部分云服务内建支持的第三方平台上为 `openid` 字段，在其他第三方平台（包括部分云服务专门支持的第三方平台和所有云服务没有专门支持的第三方平台）上为 `uid` 字段。

#### 自动验证第三方平台授权信息

为了确保账户数据的有效性，云端还支持对部分平台的 access token 的有效性进行自动验证，以防止伪造账户数据。如果有效性验证不通过，云端会返回 `invalid authData` 错误，关联不会被建立。对于云端无法识别的服务，开发者需要自己去验证 access token 的有效性。
比如，注册、登录时分别通过云引擎的 `beforeSave hook`、`beforeUpdate hook` 来验证 access token 有效性。

如果希望使用这一功能，则在开始使用前，需要在 **控制台 > 内建账户 > 设置** 配置相应平台的 **应用 ID** 和 **应用 Secret Key**。

如果不希望云端自动验证 access token，可以在 **控制台 > 内建账户 > 设置** 里面取消勾选 **第三方登录时，验证用户 AccessToken 合法性**。

配置平台账号的目的在于创建 `{{ userObjectName }}` 时，云端会使用相关信息去校验请求参数 `thirdPartyData` 的合法性，确保 `{{ userObjectName }}` 实际对应着一个合法真实的用户，确保平台安全性。

#### 绑定第三方账户

用户已经有了 LCUser 并登录成功后，可以绑定新的第三方账号信息。
绑定成功后，新的第三方账户信息会被添加到 LCUser 的 authData 字段里。

例如，下面的代码可以关联微信账户：


{% if platform_name === "JavaScript" %}
```js
user.associateWithAuthData(weixinData, 'weixin').then(function(user) {
  // 成功绑定
}).catch(function(error) {
  console.error("error: ", error);
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
user.link_with("weixin", weixin_data)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$user->linkWith("weixin", $weixinData);
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
currentUser.associate(authData: weixinData, platform: .weixin) { (result) in
    switch result {
    case .success:
        // 关联成功
    case .failure(error: let error):
        // 关联失败
    }
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
await currentUser.associateAuthData(weixinData, 'weixin');
```
{% endif %}


为节省篇幅，上面的代码示例中没有给出具体的微信平台授权信息，相关内容请参考上面的[「第三方账户登录」](#第三方账户登录)一节。

#### 解除与第三方账户的关联

类似地，可以解绑第三方账户。

例如，下面的代码可以解除用户和微信账户的关联：

{% if platform_name === "JavaScript" %}
```js
user.dissociateAuthData('weixin').then((s) => {
  // 解除关联成功
}, (error) => {
  // 解除关联失败
});
```
{% endif %}

{% if platform_name === "Python" %}
```python
user.unlink_from("weixin")
```
{% endif %}

{% if platform_name === "PHP" %}
```php
$user->unlinkWith("weixin");
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
currentUser.disassociate(authData: .weixin) { (result) in
    switch result {
    case .success:
        // 解除关联成功
    case .failure(error: let error):
        // 解除关联失败
    }
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
LCUser currentUser = await LCUser.getCurrent();
await currentUser.disassociateWithAuthData('weixin');
```
{% endif %}

#### 扩展：第三方登录时补充完整的用户信息

有些产品，新用户在使用第三方账号授权拿到相关信息后，仍然需要补充设置用户名、手机号、密码等重要信息后，才被允许登录成功。

这时要使用 `loginWithauthData` 登录接口的 `failOnNotExist` 参数并将其设置为 `true`。服务端会判断是否已存在能匹配上的 `authData`，如果不存在则会返回 `211` 错误码和 `Could not find user` 报错信息。开发者根据这个 `211` 错误码，跳转到要求输入用户名、密码、手机号等信息的页面，实例化一个 `{{ userObjectName }}` 对象，保存上述补充数据，再次调用 `loginWithauthData` 接口进行登录，并 **不再传入 `failOnNotExist` 参数**。示例代码如下：

{% if platform_name === "JavaScript" %}
```js
const thirdPartyData = {
  access_token: 'ACCESS_TOKEN',
  expires_in: 7200,
  refresh_token: 'REFRESH_TOKEN',
  openid: 'OPENID',
  scope: 'SCOPE',
};
AV.User.loginWithAuthData(thirdPartyData, 'weixin', { failOnNotExist: true }).then((s) => {
  // 登录成功
}, (error) => {
  // 登录失败
  // 检查 error.code == 211，跳转到用户名、手机号等资料的输入页面
});

const user = new AV.User();
// 设置用户名
user.setUsername('Tom');
// 设置密码
user.setMobilePhoneNumber('+8618200008888');
user.setPassword('cat!@#123');
// 设置邮箱
user.setEmail('tom@leancloud.rocks');
user.loginWithAuthData(thirdPartyData, 'weixin').then((loggedInUser) => {
  console.log(loggedInUser);
}, (error) => {
});
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let thirdPartyData: [String: Any] = [
    "access_token": "ACCESS_TOKEN",
    "expires_in": 7200,
    "refresh_token": "REFRESH_TOKEN",
    "openid": "OPENID",
    "scope": "SCOPE"
]
let user = LCUser()
user.logIn(authData: thirdPartyData, platform: .weixin, options: [.failOnNotExist]) { (result) in
    switch result {
    case .success:
        assert(user.objectId != nil)
    case .failure(error: let error):
        if error.code == 211 {
            // 不存在绑定了当前 authData 的 User 的实例
            // 跳转到输入用户名、密码、手机号等业务页面
            let user = LCUser()
            user.username = "Tom"
            user.password = "cat!@#123"
            user.mobilePhoneNumber = "+8618200008888"
            user.logIn(authData: thirdPartyData, platform: .weixin, completion: { (result) in
                switch result {
                case .success:
                    assert(user.objectId != nil)
                case .failure(error: let error):
                    print(error)
                }
            })
        }
    }
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
try {
  Map<String, dynamic> thirdPartyData = {
    // 必须
    'openid': 'OPENID',
    'access_token': 'ACCESS_TOKEN',
    'expires_in': 7200,

    // 可选
    'refresh_token': 'REFRESH_TOKEN',
    'scope': 'SCOPE'
  };
  LCUserAuthDataLoginOption option = new LCUserAuthDataLoginOption();
  option.failOnNotExist = true;
  LCUser currentUser = await LCUser.loginWithAuthData(thirdPartyData, 'weixin', option: option);
} on LCException catch (e) {
  if (e.code == 211) {
    // 不存在 authData 的 LCUser 的实例，跳转到输入用户名、密码、手机号等业务页面
  }
}

// 跳转到输入用户名、密码、手机号等业务页面之后
Map<String, dynamic> thirdPartyData = {
  'expires_in': 7200,
  'openid': 'OPENID',
  'access_token': 'ACCESS_TOKEN'
};
try {
  LCUserAuthDataLoginOption option = new LCUserAuthDataLoginOption();
  option.failOnNotExist = true;
  LCUser user = await LCUser.loginWithAuthData(thirdPartyData, 'weixin', option: option);
  user.username = 'Tome';
  user.mobile = '+8618200008888';
  await user.save();
} on LCException catch (e) {
    //其他报错信息
}
```
{% endif %}

#### 扩展：接入 UnionID 体系，打通不同子产品的账号系统

随着第三方平台的账户体系变得日渐复杂，它们的第三方鉴权信息出现了一些较大的变化。下面我们以最典型的微信开放平台为例来进行说明。

当一个用户在移动应用内登录微信账号时，会被分配一个 OpenID；在微信小程序内登录账号时，又会被分配另一个不同的 OpenID。这样的架构会导致的问题是，使用同一个微信号的用户，也无法在微信开发平台下的移动应用和小程序之间互通。

微信官方为了解决这个问题，引入了 `UnionID` 的体系，以下为其官方说明：

> 通过获取用户基本信息接口，开发者可通过 OpenID 来获取用户基本信息，而如果开发者拥有多个公众号，可使用以下办法通过 UnionID 机制来在多公众号之间进行用户帐号互通。只要是同一个微信开放平台帐号下的公众号，用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台帐号下的不同应用，UnionID 是相同的。

其他平台，如 QQ 和微博，与微信的设计也基本一致。

云服务支持 `UnionID` 体系。你只需要给 `loginWithauthData` 和 `associateWithauthData` 接口传入更多的第三方鉴权信息，即可完成新 UnionID 体系的集成。新增加的第三方鉴权登录选项包括：

- unionId，指第三方平台返回的 UnionId 字符串。
- unionId platform，指 unionId 对应的 platform 字符串，由应用层自己指定，[后面](#该如何指定-unionIdPlatform)会详述。
- asMainAccount，指示是否把当前平台的鉴权信息作为主账号来使用。如果作为主账号，那么就由当前用户唯一占有该 unionId，以后其他平台使用同样的 unionId 登录的话，会绑定到当前的用户记录上来；否则，当前应用的鉴权信息会被绑定到其他账号上去。

下面让我们通过一个例子来说明如何使用这些参数完成 UnionID 登录。

假设云服务在微信开放平台上有两个应用，一个是「云服务通讯」，一个是「云服务技术支持」，这两个应用在接入第三方鉴权的时候，分别使用了 `wxleanoffice` 和 `wxleansupport` 作为 platform 来进行登录。现在我们开启 UnionID 的用户体系，希望同一个微信用户在这两个应用中都能对应到同一个账户系统（_User 表中的同一条记录），同时我们决定将 `wxleanoffice` 平台作为主账号平台。

假设对于用户 A，微信给 ta 为 云服务分配的 UnionId 为 `unionid4a`，而对两个应用的授权信息分别为：

```json
"wxleanoffice": {
  "access_token": "officetoken",
  "openid": "officeopenid",
  "expires_in": 1384686496
},
"wxleansupport": {
  "openid": "supportopenid",
  "access_token": "supporttoken",
  "expires_in": 1384686496
}
```

现在，用户 A 在「云服务通讯」中通过微信登录，其调用请求为：

{% if platform_name === "JavaScript" %}
```js
const thirdPartyData = {
  access_token: 'officetoken',
  expires_in: 1384686496,
  uid: 'officeopenid',
  scope: 'SCOPE',
};

AV.User.loginWithAuthDataAndUnionId(
  thirdPartyData,
  'wxleanoffice', 'unionid4a',  // 新增参数
  {
    unionIdPlatform: 'weixin',   // 这里指定 UnionIdPlatform，使用「weixin」来指代微信平台。
    asMainAccount: true,
  }
).then((user) => {
  // 绑定成功
}, (error) => {
  // 绑定失败
});
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let thirdPartyData: [String: Any] = [
    "access_token": "officetoken",
    "expires_in": 1384686496,
    "uid": "officeopenid",
    "scope": "SCOPE",
    "unionid": "unionid4a" // 新增属性
]
let user = LCUser()
user.logIn(
    authData: thirdPartyData,
    platform: .custom("wxleanoffice"),
    unionID: thirdPartyData["unionid"] as? String,
    unionIDPlatform: .weixin,   // 这里指定 UnionIdPlatform，使用「weixin」来指代微信平台。
    options: [.mainAccount])
{ (result) in
    switch result {
    case .success:
        assert(user.objectId != nil)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
Map<String, dynamic> thirdPartyData = {
  // 必须
  'uid': 'officeopenid',
  'access_token': 'officetoken',
  'expires_in': 1384686496,
  'unionId': 'unionid4a',   // 新增属性

  // 可选
  'refresh_token': '...',
  'scope': 'SCOPE'
};
LCUserAuthDataLoginOption option = LCUserAuthDataLoginOption();
option.asMainAccount = true;
option.unionIdPlatform = 'weixin';
LCUser currentUser = await LCUser.loginWithAuthDataAndUnionId(
    thirdPartyData, 'wxleanoffice', 'unionid4a',
    option: option);
```
{% endif %}

> 注意代码中将微信传回来的 openid 属性改为了 uid，这是因为云端要求对于自定义的 platform，只能使用 uid 这样的属性名，才能保证自动建立 `authData.<PLATFORM>.uid` 的唯一索引，具体可以参考《数据存储 REST API 使用详解》的《连接用户账户和第三方平台》。

如果用户 A 是第一次在「云服务通讯」中通过微信登录，那么 _User 表中会增加一个新用户（假设其 objectId 为 `ThisIsUserA`），其 `authData` 的结果如下：

```json
{
  "wxleanoffice": {
    "platform": "weixin",
    "uid": "officeopenid",
    "expires_in": 1384686496,
    "main_account": true,
    "access_token": "officetoken",
    "unionid": "unionid4a"
  },
  "_weixin_unionid": {   // 新增键值对
    "uid": "unionid4a"
  }
}
```

可以看到，与之前的第三方登录 API 相比，这里由于登录时指定了 `asMainAccount` 为 true，所以 authData 的第一级子目录中增加了 `_weixin_unionid` 的键值对，这里的 `weixin` 就是我们指定的 `unionIdPlatform` 的值。`_weixin_unionid` 这个增加的键值对非常重要，以后我们判断是否存在同样 UnionID 的账户就是依靠它来查找的，而是否增加这个键值对，则是由登录时指定的 `asMainAccount` 的值决定的：

- 当 `asMainAccount` 为 true 时，云端会在 `authData` 下面增加名为 `_{unionIdPlatform}_unionid` 的键值对，当前账号就会作为这一个 UnionID 对应的主账号被唯一确定。
- 当 `asMainAccount` 为 false 时，云端不会在 `authData` 下面增加名为 `_{unionIdPlatform}_unionid` 的键值对，此时如果通过提供的 UnionID 可以找到主账号，则会将当前的鉴权信息合并进主账号的 `authData` 属性里，同时返回主账号对应的 _User 表记录；如果通过提供的 UnionID 找不到主账号，则会根据平台的 `openid` 去查找账户，找到匹配的账户就返回匹配的，找不到就新建一个账户，此时的处理逻辑与不使用 UnionID 时的逻辑完全一致。


接下来，用户 A 继续在「云服务技术支持」中进行微信登录，其登录逻辑为：

{% if platform_name === "JavaScript" %}
```js
const thirdPartyData = {
  access_token: 'supporttoken',
  expires_in: 1384686496,
  uid: 'supportopenid',
  scope: 'SCOPE',
};

AV.User.loginWithAuthDataAndUnionId(
  thirdPartyData,
  'wxleansupport', 'unionid4a',
  {
    unionIdPlatform: 'weixin',   // 这里指定 unionIdPlatform，使用「weixin」来指代微信平台。
    asMainAccount: false,
  }
).then((user) => {
  // 绑定成功
}, (error) => {
  // 绑定失败
});
```
{% endif %}

{% if platform_name === "Swift" %}
```swift
let thirdPartyData: [String: Any] = [
    "access_token": "supporttoken",
    "expires_in": 1384686496,
    "uid": "supportopenid",
    "scope": "SCOPE",
    "unionid": "unionid4a"
]
let user = LCUser()
user.logIn(
    authData: thirdPartyData,
    platform: .custom("wxleansupport"),
    unionID: thirdPartyData["unionid"] as? String,
    unionIDPlatform: .weixin,  // 这里指定 unionIdPlatform，使用「weixin」来指代微信平台。
    options: [.mainAccount])
{ (result) in
    switch result {
    case .success:
        assert(user.objectId != nil)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
Map<String, dynamic> thirdPartyData = {
  // 必须
  'uid': 'supportopenid',
  'access_token': 'supporttoken',
  'expires_in': 1384686496,
  'unionId': 'unionid4a',

  // 可选
  'refresh_token': '...',
  'scope': 'SCOPE'
};
LCUserAuthDataLoginOption option = LCUserAuthDataLoginOption();
option.asMainAccount = false;
option.unionIdPlatform = 'weixin';     // 这里指定 unionIdPlatform，使用「weixin」来指代微信平台。
LCUser currentUser = await LCUser.loginWithAuthDataAndUnionId(
    thirdPartyData, 'wxleansupport', 'unionid4a',
    option: option);
```
{% endif %}

与「云服务通讯」中的登录过程相比，在「云服务技术支持」这个应用中，我们在登录时只是将 `asMainAccount` 设为了 false。 这时我们看到，本次登录得到的还是 objectId 为 `ThisIsUserA` 的 _User 表记录（同一个账户），同时该账户的 `authData` 属性中发生了变化，多了 `wxleansupport` 的数据，如下：

```json
{
  "wxleanoffice": {
    "platform": "weixin",
    "uid": "officeopenid",
    "expires_in": 1384686496,
    "main_account": true,
    "access_token": "officetoken",
    "unionid": "unionid4a"
  },
  "_weixin_unionid": {
    "uid": "unionid4a"
  },
  "wxleansupport": {
    "platform": "weixin",
    "uid": "supportopenid",
    "expires_in": 1384686496,
    "main_account": false,
    "access_token": "supporttoken",
    "unionid": "unionid4a"
  }
}
```

在新的登录方式中，当一个用户以「平台名为 `wxleanoffice`、uid 为 `officeopenid`、UnionID 为 `unionid4a`」的第三方鉴权信息登录得到新的 `{{ userObjectName }}` 后，接下来这个用户以「平台名为 `wxleansupport`、uid 为 `supportopenid`、UnionID 为 `unionid4a`」的第三方鉴权信息登录时，云端判定是同样的 UnionID，就直接把来自 `wxleansupport` 的新用户数据加入到已有账户的 `authData` 里了，不会再创建新的账户。

这样一来，云端通过识别平台性的用户唯一标识 UnionID，让来自同一个 UnionID 体系内的应用程序、小程序等不同平台的用户都绑定到了一个 `{{ userObjectName }}` 上，实现互通。

##### 为 UnionID 建立索引

云端会为 UnionID 自动建立索引，不过因为自动创建基于请求的抽样统计，可能会滞后。
因此，我们推荐自行创建相关索引，特别是用户量（`_User`　表记录数）很大的应用，更需要预先创建索引，否则用户使用 UnionID 账号登录时可能超时失败。
以上面的微信 UnionID 为例，建议在控制台预先创建下列唯一索引（允许缺失值）：

- `authData.wxleanoffice.uid`
- `authData.wxleansupport.uid`
- `authData._weixin_unionid.uid`

##### 该如何指定 unionIdPlatform

从上面的例子可以看出，使用 UnionID 登录的时候，需要指定 `unionIdPlatform` 的主要目的，就是为了便于查找已经存在的唯一主账号。云端会在主账号对应账户的 `authData` 属性中增加一个 `_{unionIdPlatform}_unionid` 键值对来标记唯一性，终端用户在其他应用中登录的时候，云端会根据参数中提供的 `uniondId` + `unionIdPlatform` 的组合，在 `_User` 表中进行查找，这样来确定唯一的既存主账号。

本来 `unionIdPlatform` 的取值，应该是开发者可以自行决定的，但是 JavaScript SDK 基于易用性的目的，在 `loginWithAuthDataAndUnionId` 之外，还额外提供了两个接口：

- `AV.User.loginWithQQAppWithUnionId`，这里默认使用 `qq` 作为 `unionIdPlatform`。
- `AV.User.loginWithWeappWithUnionId`，这里默认使用 `weixin` 作为 `unionIdPlatform`。

从我们的统计来看，这两个接口已经被很多开发者接受，在大量线上产品中产生着实际数据。所以为了避免数据在不同平台（例如 Android 和 iOS 应用）间发生冲突，建议大家统一按照 JavaScript SDK 的默认值来设置 `unionIdPlatform`，即：

- 微信平台的多个应用，统一使用 `weixin` 作为 `unionIdPlatform`；
- QQ 平台的多个应用，统一使用 `qq` 作为 `unionIdPlatform`；
- 微博平台的多个应用，统一使用 `weibo` 作为 `unionIdPlatform`；
- 除此之外的其他平台，开发者可以自行定义 `unionIdPlatform` 的名字，只要自己保证多个应用间统一即可。


##### 主副应用不同登录顺序出现的不同结果

上面的流程是用户先登录了「云服务通讯」这个主应用，然后再登录「云服务技术支持」这个副应用，所以账号都被通过 UnionID 有效关联起来了。可能有人会想到另外一个问题，如果用户 B 先登录副应用，后登录主应用，这时候会发生什么事情呢？

用户 B 首先登录副应用的时候，提供了「平台名为 `wxleansupport`、uid 为 `supportopenid`、UnionID 为 `unionid4a`」的第三方鉴权信息，并且指定「UnionIDPlatform 为 `weixin`、`asMainAccount` 为 false」（与上面的调用完全一致），此时云端由于找不到存在的 UnionID，会新建一个 `{{ userObjectName }}` 对象，该账户 `authData` 结果为：

```json
{
  "wxleansupport": {
    "platform": "weixin",
    "uid": "supportopenid",
    "expires_in": 1384686496,
    "main_account": false,
    "access_token": "supporttoken",
    "unionid": "unionid4a"
  }
}
```

用户 B 接着又使用了主应用，ta 再次通过微信登录，此时以「平台名为 `wxleanoffice`、uid 为 `officeopenid`、UnionID 为 `unionid4a`」的第三方鉴权信息，以及「UnionIDPlatform 为 `weixin`、`asMainAccount` 为 true」的参数进行登录，此时云端由于找不到存在的 UnionID，会再次新建一个 `{{ userObjectName }}` 对象，该账户 `authData` 结果为：

```json
{
  "wxleanoffice": {
    "platform": "weixin",
    "uid": "officeopenid",
    "expires_in": 1384686496,
    "main_account": true,
    "access_token": "officetoken",
    "unionid": "unionid4a"
  },
  "_weixin_unionid": {
    "uid": "unionid4a"
  }
}
```

还有更复杂的情况。如果某公司的产品之前就接入了微信登录，产生了很多存量用户，并且分散在不同的子产品中，这时候怎么办？我们接下来专门讨论此时的解决方案。

##### 存量账户如何通过 UnionID 实现关联

还是以我们的两个子产品「云服务通讯」（后续以「产品 1」指代）和「云服务技术支持为例」（后续以「产品 2」指代），在接入 UnionID 之前，我们就接入了之前版本的微信平台登录，这时候账户系统内可能存在多种账户：

- 只使用产品 1 的微信用户 A
- 只使用产品 2 的微信用户 B
- 同时使用两个产品的微信用户 C

此时的存量账户表如下所示：

objectId | 微信用户 | authData.{platform} | authData._{platform}_unionid
------ | ------ | ------ | ------
1 | UserA | openid1（对应产品 1） | N/A
2 | UserB | openid2（对应产品 2） | N/A
3 | UserC | openid3（对应产品 1） | N/A
4 | UserC | openid4（对应产品 2） | N/A

现在我们对两个子产品进行升级，接入 UnionID 体系。这时因为已经有同一个微信用户在不同子产品中创建了不同的账户（例如 objectId 为 3 和 4 的账户），我们需要确定以哪个平台的账号为主。比如决定使用「云服务通讯」上生成的账号为主账号，则在该应用程序更新版本时，使用 `asMainAccount=true` 参数。这个应用带着 UnionID 登录匹配或创建的账号将作为主账号，之后所有这个 UnionID 的登录都会匹配到这个账号。请注意这时 `_User` 表里会剩下一些用户数据，也就是没有被选为主账号的、其他平台的同一个用户的旧账号数据（例如 objectId 为 2 和 4 的账户）。这部分数据会继续服务于已经发布的但仍然使用 OpenID 登录的旧版应用。

接下来我们看一下，如果以产品 1 的账户作为「主账户」，按照前述的方式同时提供 openid/unionid 完成登录，则最后达到的结果是：

1. 使用老版本的用户，不管在哪个产品里面，都可以和往常一样通过 openid 登录到正确的账户；
2. 使用产品 1 的新版本的老用户，通过 openid/unionid 组合，还是绑定到原来的账户。例如 UserC 在产品 1 中通过 openid3/unionId3 还是会绑定到 objectId=3 的账户（会增加 uniondId 记录）；而 UserC 在产品 2 的新版本中，通过 openid4/unionId3 的组合则会绑定到 objectId=3 的账户，而不再是原来的 objectId=4 的账户。
3. 使用产品 1 的新版本的新用户，通过 openid/unionid 组合，会创建新的账户；之后该用户再使用产品 2 的新版本，也会绑定到刚才创建的新账户上。

以上面的三个用户为例，他们分别升级到两个产品的最新版，且最终都会启用两个产品，则账户表的最终结果如下：

objectId | 微信用户 | authData.{platform} | authData._{platform}_unionid
------ | ------ | ------ | ------
1 | UserA | openid1（对应产品 1）/openid6（对应产品 2） | unionId_user_A
2 | UserB | openid2（对应产品 2） | N/A
3 | UserC | openid3（对应产品 1）/openid4（对应产品 2） | unionId_user_C
4 | UserC | openid4（对应产品 2） | N/A
5 | UserB | openid5（对应产品 1）/openid2（对应产品 2） | unionId_user_B

之后有新的用户 D，分别在两个产品的新版本中登录，则账户表中会增加一条新的 objectId=6 的记录，结果如下：

objectId | 微信用户 | authData.{platform} | authData._{platform}_unionid
------ | ------ | ------ | ------
1 | UserA | openid1（对应产品 1）/openid6（对应产品 2） | unionId_user_A
2 | UserB | openid2（对应产品 2） | N/A
3 | UserC | openid3（对应产品 1）/openid4（对应产品 2） | unionId_user_C
4 | UserC | openid4（对应产品 2） | N/A
5 | UserB | openid5（对应产品 1）/openid2（对应产品 2） | unionId_user_B
6 | UserD | openid7（对应产品 1）/openid8（对应产品 2） | unionId_user_D

如果之后我们增加了新的子产品 3，这些用户在子产品 3 中也进行微信登录的话，那么四个用户还是会继续绑定到 objectId 为 1/3/5/6 的主账户。此时账户表的结果会变为：

objectId | 微信用户 | authData.{platform} | authData._{platform}_unionid
------ | ------ | ------ | ------
1 | UserA | openid1（对应产品 1）/openid6（对应产品 2）/openid9（对应产品 3） | unionId_user_A
2 | UserB | openid2（对应产品 2） | N/A
3 | UserC | openid3（对应产品 1）/openid4（对应产品 2）/openid10（对应产品 3） | unionId_user_C
4 | UserC | openid4（对应产品 2） | N/A
5 | UserB | openid5（对应产品 1）/openid2（对应产品 2）/openid11（对应产品 3） | unionId_user_B
6 | UserD | openid7（对应产品 1）/openid8（对应产品 2）/openid12（对应产品 3） | unionId_user_D

### 匿名用户

将数据与用户关联需要首先创建一个用户，但有时你不希望强制用户在一开始就进行注册。使用匿名用户，可以让应用不提供注册步骤也能创建用户。下面的代码创建一个新的匿名用户：


{% if platform_name === "JavaScript" %}
```js
AV.User.loginAnonymously().then((user) => {
  // user 是新的匿名用户
});
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
await LCUser.loginAnonymously();
```
{% endif %}


可以像给普通用户设置属性那样给匿名用户设置 `username`、`password`、`email` 等属性，还可以通过走正常的注册流程来将匿名用户转化为普通用户。匿名用户能够：

- [使用用户名和密码注册](#注册)
- [关联第三方平台](#第三方账户登录)，比如微信

下面的代码为一名匿名用户设置用户名和密码：

{% if platform_name === "JavaScript" %}
```js
// currentUser 是个匿名用户
const currentUser = AV.User.current();

user.setUsername('Tom');
user.setPassword('cat!@#123');

user.signUp().then((user) => {
  // currentUser 已经转化为普通用户
}, (error) => {
  // 注册失败（通常是因为用户名已被使用）
});
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
LCUser currentUser = await LCUser.loginAnonymously();
currentUser.username = 'Tom';
currentUser.password = 'cat!@#123';

await currentUser.signUp();
```
{% endif %}

下面的代码检查当前用户是否为匿名用户：


{% if platform_name === "JavaScript" %}
```js
const currentUser = AV.User.current();
if (currentUser.isAnonymous()) {
  // currentUser 是匿名用户
} else {
  // currentUser 不是匿名用户
}
```
{% endif %}

{% if platform_name === "Flutter" %}
```dart
LCUser currentUser = await LCUser.getCurrent();
if (currentUser.isAnonymous) {
  // currentUser 是匿名用户
} else {
  // currentUser 不是匿名用户
}
```
{% endif %}


如果匿名用户未能在登出前转化为普通用户，那么该用户将无法再次登录同一账户，且之前产生的数据也无法被取回。


## 角色

随着用户量的增长，你可能会发现相比于为每一名用户单独设置权限，将预先设定好的权限直接分配给一部分用户是更好的选择。为了迎合这种需求，云服务支持基于角色的权限管理。请参阅 [ACL 权限管理开发指南](acl-guide.html)。

{% if platform_name === "Objective-C" or platform_name === "Python" or platform_name === "PHP" or platform_name === "Swift" %}
## 子类化

{% if platform_name === "Python" %}
云服务希望设计成能让人尽快上手并使用。你可以通过 `{{baseObjectName}}.get()` 方法访问所有的数据。但是在很多现有成熟的代码中，子类化能带来更多优点，诸如简洁、可扩展性以及 IDE 提供的代码自动完成的支持等等。子类化不是必须的，你可以将下列代码转化：

```python
import leancloud

student = leancloud.Object.extend("Student")()
student.set('name', '小明')
student.save()
```

可改写成：

```python
import leancloud

class Student(leancloud.Object):
    pass

student = Student()
student.set('name', '小明')
student.save()
```

### 子类化 `leancloud.Object`

要实现子类化，需要下面几个步骤：

1. 首先声明一个子类继承自 `leancloud.Object`；
2. 子类化时如果有自定义的构造函数，需要在构造函数中调用父类的构造函数。

下面是实现 `Student` 子类化的例子：

```python
import leancloud

class Student(leancloud.Object):
    pass

student = Student()
student.set('name', 'Tom')
student.save()
```

### 访问器、修改器和方法

添加方法到 `leancloud.Object` 的子类有助于封装类的逻辑。你可以将所有跟子类有关的逻辑放到一个地方，而不是分成多个类来分别处理业务逻辑和存储或转换逻辑。

你可以很容易地为 `leancloud.Object` 子类添加访问器和修改器。像平常那样声明字段的 `getter` 和 `setter` 方法，但是通过 `leancloud.Object` 的 `get` 和 `set` 方法来实现它们。下面是这个例子为 `Student` 类创建了一个 `content` 的字段：

```python
import leancloud

class Student(leancloud.Object):
    @property
    def content(self):
        # 可以使用 property 装饰器，方便获取属性
        return self.get('content')

    @content.setter
    def content(self, value):
        # 同样可以给对象的 content 增加 setter
        return self.set('content', value)
```

现在你就可以使用 `student.content` 方法来访问 `content` 字段，并通过 `student.content = "blah blah blah"` 来修改它，并且可以通过 IDE 或者 linter 在运行前就可以发现类型错误。

如果你不仅需要一个简单的访问器，而是有更复杂的逻辑，你可以在子类化时定义和实现自己的方法。

### 初始化子类

你可以使用自定义的构造函数来创建子类对象。子类必须定义一个公开的默认构造函数，并且不修改任何父类 `leancloud.Object` 中的字段，这个默认构造函数将会被 SDK 使用来创建子类的强类型的对象。

要创建一个到现有对象的引用，可以使用 `leancloud.Object.create_without_data()`：

```python
import leancloud

Student = leancloud.Object.extend('Student')
student = Student.create_without_data('573a8459df0eea005e6b711c')
student.fetch()
```

### 查询子类

你可以通过对象的 `query` 属性获取特定的子类的查询对象。下面的例子就查询了用户发表的所有微博列表：

```python
import leancloud

query = leancloud.Query('Student')
user_name = leancloud.User.get_current().get_username()
query.equal_to('publeancloud.User', user_name)
student_list = query.find()

for student in student_list:
    # 你的逻辑
    pass
```
### User 的子类化

leancloud.User 作为 `leancloud.Object` 的子类，同样允许子类化，你可以定义自己的 User 对象。需要继承 User，并且将子类的 `_class_name` 设为 `'_User'`：

```python
import leancloud

class MyUser(leancloud.User):
    def __init__(self):
        leancloud.User.__init__(self)
        self._class_name = '_User' # 这里要指定 _class_name 为 _User

    def set_nickname(self, name):
        self.set('nick_name', name)

    def get_nickname(self):
        return self.get('nick_name')
```
{% endif %}
{% if platform_name === "PHP" %}
云服务希望设计成能让人尽快上手并使用。你可以通过 `LeanObject#get` 方法访问所有的数据。但是在很多现有成熟的代码中，子类化能带来更多优点，诸如简洁、可扩展性以及 IDE 提供的代码自动完成的支持等等。子类化不是必须的，你可以将下列代码转化：

```php
$student = new LeanObject("Student");
$student->set("name", "小明");
$student->save();
```

可改写成：

```php
$student = new Student();
$student->set("name", "小明");
$student->save();
```

这样代码看起来是不是更简洁呢？

### 子类化 LCObject

要实现子类化，需要下面几个步骤：

1. 首先声明一个子类继承自 `LeanObject`；
2. 子类中声明静态字段 `protected static $className`，对应云端的数据表名；
3. 建议不要重载构造函数 `__construct()`，如果一定需要构造，请确保其接受 2 个参数 `$className` 和 `$objectId`；
4. 将子类注册到 `LeanObject`，如 `Student::registerClass();`。

下面是实现 `Student` 子类化的例子：

```php
// Student.php
use LeanCloud\LeanObject;

class Student extends LeanObject {
    protected static $className = "Student";
}
Student::registerClass();
```

### 访问器、修改器和方法

添加方法到 `LeanObject` 的子类有助于封装类的逻辑。你可以将所有跟子类有关的逻辑放到一个地方，而不是分成多个类来分别处理商业逻辑和存储/转换逻辑。

你可以很容易地添加访问器和修改器到你的 `LeanObject` 子类。像平常那样声明字段的 `getter` 和 `setter` 方法，但是通过 `LeanObject` 的 `get` 和 `set` 方法来实现它们。下面是这个例子为 `Student` 类创建了一个 `content` 的字段：

```php
// Student.php
use LeanCloud\LeanObject;

class Student extends LeanObject {
    protected static $className = "Student";

    public function setContent($value) {
        $this->set("content", $value);
        return $this; // 方便链式调用
    }

    public function getContent() {
        return $this->get("content");
    }
}
Student::registerClass();
```

现在你就可以使用 `$student->getContent()` 方法来访问 `content` 字段，并通过 `$student->setContent("blah blah blah")` 来修改它。

各种数据类型的访问器和修改器都可以这样被定义，使用各种 `get()` 方法的变种，例如 `getInt()`，`getFile()` 或者 `getMap()`。

如果你不仅需要一个简单的访问器，而是有更复杂的逻辑，你也可以实现自己的方法，例如：

```php
public function takeAccusation() {
  // 处理用户举报，当达到某个条数的时候，自动打上屏蔽标志
  $this->increment("accusation", 1);
  if ($this->getAccusation() > 50) {
    $this->setSpam(true);
  }
}
```

### 初始化子类

你可以使用你自定义的构造函数来创建你的子类对象。`LeanObject` 已定义了默认的构造函数，如果需要重载构造函数，请注意其需要接收 2 个参数：`$className` 和 `$objectId`。这个构造函数将会被 SDK 使用来创建子类的对象。

要创建一个到现有对象的引用，可以使用 `LeanObject::create("Student", "abc123")`：

```php
$student = LeanObject::create("Student", "573a8459df0eea005e6b711c");
```

### 查询子类

你可以通过 `LeanObject#getQuery()` 方法获取特定的子类的查询对象。下面的例子就查询了用户发表的所有微博列表：

```php
$query = $post->getQuery();
$query->equalTo("pubUser", User::getCurrentUser()->getUsername());
$query->find();
```
{% endif %}
{% if platform_name === "Swift" %}
子类化推荐给进阶的开发者在进行代码重构的时候做参考。你可以用 `LCObject` 访问到所有的数据，用 `get` 方法获取任意字段，用 `set` 方法给任意字段赋值；你也可以使用子类化来封装 `get` 以及 `set` 方法，增强编码体验。子类化有很多优势，包括减少代码的编写量，具有更好的扩展性，和支持自动补全等等。

### 子类化的实现

要实现子类化，需要下面两个步骤：

1. 继承 `LCObject`；
2. 重载静态方法 `objectClassName`，返回的字符串是原先要传递给 `LCObject(className:)` 初始化方法的参数。如果不实现，默认返回的是类的名字。**请注意：`LCUser` 子类化后必须返回 `_User`**；
3. 注册子类。一般在 `application(_:didFinishLaunchingWithOptions:)` 方法中调用 `static func register()` 方法。

下面是实现 `Student` 子类化的例子：

```swift
class Student: LCObject {

    @objc dynamic const name: LCString?

    override static func objectClassName() -> String {
        return "Student"
    }
}

func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {

    Student.register()

    return true
}
```

### 将 Setter 以及 Getter 方法封装成属性

可以将 `LCObject` 的 Setter 和 Getter 方法封装成属性，需使用 `@objc dynamic var` 来声明一个变量，**且该变量的类型为 [`LCValue`](#数据类型)**。

如下所示，两段代码对 `name` 字段的赋值方式等价。

```swift
// Set name for LCObject
do {
    let student = LCObject(className: "Student")
    try student.set("name", value: "小明")
    assert(student.save().isSuccess)
} catch {
    print(error)
}
```
```swift
// Set name for Student
let student = Student()
student.name = LCString("小明")
assert(student.save().isSuccess)
```
{% endif %}
{% endif %}

{% if platform_name === "Flutter" %}

## 子类化

子类化推荐给进阶的开发者在进行代码重构的时候做参考。你可以用 `LCObject` 重载符 [] 访问/赋值任意字段；你也可以使用子类化的属性来封装获取字段的方法，增强编码体验。子类化有很多优势，包括减少代码的编写量，具有更好的扩展性，和支持自动补全等等。

### 实现

要实现子类化，需要下面三个步骤：

1. 继承 `LCObject`；
2. 重载构造方法，传入 `类名`；
3. 注册子类

下面是实现 `Student` 子类化的例子：

```dart
// 定义 Student 类型
class Student extends LCObject {
  String get name => this['name'];

  set name(String value) => this['name'] = value;

  Student() : super('Student');
}

// 注册 Student 子类
LCObject.registerSubclass<Student>('Student', () => new Student());
```

### 使用

如下所示，两段代码对 name 字段的赋值方式等价。

```dart
LCObject student = new LCObject("Student");
student["name"] = "小明";
await student.save();
```

```dart
Student student = new Student();
student.name = "小明";
await student.save();
```

{% endif %}

{% if platform_name === "Swift" %}

## 多线程安全

SDK 提供了一个便利的选项，可以确保 `LCObject` 的属性的存取操作在多线程环境中是安全的，该选项默认为关闭，开启示例如下：

```swift
var config = LCApplication.Configuration()
config.isObjectRawDataAtomic = true
do {
    try LCApplication.default.set(
        id: {{appid}},
        key: {{appkey}},
        serverURL: "https://please-replace-with-your-customized.domain.com"
        configuration: config)
} catch {
    print(error)
}
```

开启该选项后，每个 `LCObject` 实例对象的属性的存取操作都会被加锁。通常来说，锁以及加锁、解锁操作会有一定的开销，是否开启该选项需要开发者根据实际情况衡权利弊后决定。

如果对性能不敏感，同时又不想额外处理数据竞争的情况，可以选择开启该选项。

如果对性能非常敏感，或者程序中不可能出现数据竞争的情况，那么不用开启该选项。

{% endif %}

## 全文搜索

全文搜索是一个针对应用数据进行全局搜索的接口，它基于搜索引擎构建，提供更强大的搜索功能。要深入了解其用法和阅读示例代码，请阅读 [全文搜索指南](app_search_guide.html)。

{% if node !== "qcloud" %}
## 应用内社交

应用内社交包含「好友关系」及「信息流」，例如陌生人的关注、好友申请、朋友圈、状态等，请参考[好友关系开发指南](leanstorage_friendship_guide.html)及[社交信息流开发指南](status_system.html)。

{% endif %}

{% if platform_name === "JavaScript" %}
## WebView

JS SDK 支持在各种 WebView 中使用，包括 PhoneGap、Cordova、微信 WebView 等。

### Android WebView

如果是 Android WebView，在 Native 代码创建 WebView 的时候你需要打开几个选项，这些选项生成 WebView 的时候默认并不会被打开，需要配置：

1. 因为我们 JS SDK 目前使用了 `window.localStorage`，所以你需要开启 WebView 的 `localStorage`：

   ```java
   yourWebView.getSettings().setDomStorageEnabled(true);
   ```

2. 如果你希望直接调试手机中的 WebView，也同样需要在生成 WebView 的时候设置远程调试，具体使用方式请参考 [Google 官方文档](https://developer.chrome.com/devtools/docs/remote-debugging)。

   ```java
   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
     yourWebView.setWebContentsDebuggingEnabled(true);
   }
   ```

   注意：这种调试方式仅支持 Android 4.4 以上版本（含 4.4）。
3. 如果你是通过 WebView 来开发界面，Native 调用本地特性的 Hybrid 方式开发你的 App。比较推荐的开发方式是：通过 Chrome 的开发者工具开发界面部分，当界面部分完成，与 Native 再来做数据连调，这种时候才需要用 Remote debugger 方式在手机上直接调试 WebView。这样做会大大节省你开发调试的时间，不然如果界面都通过 Remote debugger 方式开发，可能效率较低。

4. 为了防止通过 JavaScript 反射调用 Java 代码访问 Android 文件系统的安全漏洞，在 Android 4.2 以后的系统中，WebView 中间只能访问通过 [`@JavascriptInterface`](http://developer.android.com/reference/android/webkit/JavascriptInterface.html) 标记过的方法。如果你的目标用户覆盖 4.2 以上的机型，请注意加上这个标记，以避免出现 `Uncaught TypeError`。
{% endif %}


<!-- This code is for Google Ads -->
{% include 'templates/include/ga-config.html' %}
